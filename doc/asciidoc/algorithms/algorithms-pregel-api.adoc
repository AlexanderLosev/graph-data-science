[[algorithms-pregel-api]]
= Pregel API

[abstract]
--
This chapter provides documentation for the Pregel API in the Neo4j Graph Data Science library.
--

This topic includes:

* <<algorithms-pregel-api-intro, Introduction>>
* <<algorithms-pregel-api-java, Pregel Java API>>
** <<algorithms-pregel-api-java-computation, Computation>>
** <<algorithms-pregel-api-java-context, Init context and computation context>>
** <<algorithms-pregel-api-java-config, Configuration>>
* <<algorithms-pregel-api-procedure, Exposing a Pregel algorithm via Cypher>>
** <<algorithms-pregel-api-procedure-generation, Procedure generation>>
** <<algorithms-pregel-api-plugin, Building and installing a Neo4j plugin>>
** <<algorithms-pregel-api-example, Example: Connected Components>>

[[algorithms-pregel-api-intro]]
== Introduction

Pregel is a vertex-centric computation model to define your own algorithms via a user-defined _compute_ function.
Node values can be updated within the compute function and represent the algorithm result.
The input graph contains default node values or node values from a graph projection.

The compute function is executed in multiple iterations, also called _supersteps_.
In each superstep, the compute function runs for each node in the graph.
Within that function, a node can receive messages from other nodes, typically its neighbors.
Based on the received messages and its currently stored value, a node can compute a new value.
A node can also send messages to other nodes, typically its neighbors, which are received in the next superstep.
The algorithm terminates after a fixed number of supersteps or if no messages are being sent between nodes.

A Pregel computation is executed in parallel.
Each thread executes the compute function for a batch of nodes.

For more information about Pregel, have a look at https://kowshik.github.io/JPregel/pregel_paper.pdf.

To implement your own Pregel algorithm, the Graph Data Science library provides a Java API, which is described below.

The introduction of a new Pregel algorithm can be separated in two main steps.
First, we need to implement the algorithm using the Pregel Java API.
Second, we need to expose the algorithm via a Cypher procedure to make use of it.

For an example on how to expose a custom Pregel computation via a Neo4j procedure, have a look at the https://github.com/neo-technology/graph-analytics/tree/master/public/examples/pregel-example/src/main/java/org/neo4j/graphalgo/beta/pregel[Pregel examples].

[[algorithms-pregel-api-java]]
== Pregel Java API

The Pregel Java API allows us to easily build our own algorithm by implementing well-defined interfaces.

[[algorithms-pregel-api-java-computation]]
=== Computation

The first step is to implement the `https://github.com/neo-technology/graph-analytics/blob/6179f0cfef50d41af376aa6dcab4d5142ab3f8e9/public/core/src/main/java/org/neo4j/graphalgo/beta/pregel/PregelComputation.java[PregelComputation]` interface.
It is the main interface to express user-defined logic using the Pregel framework.

.The Pregel computation
[source, java]
----
public interface PregelComputation<C extends PregelConfig> {
    // The node schema describes the node property layout.
    Pregel.NodeSchema nodeSchema();
    // Called in the first superstep and allows initializing node state.
    default void init(PregelContext.InitContext<C> context) {}
    // Called in each superstep for each node and contains the main logic.
    void compute(PregelContext.ComputeContext<C> context, Pregel.Messages messages);
    // Used to apply a relationship weight on a message.
    default double applyRelationshipWeight(double message, double relationshipWeight);
}
----

The `nodeSchema` describes the node property layout.
A node property can be composed of multiple primitive values, such as double or long, as well as arrays of those.
Each part of that composite schema is named by a unique key.

The `init` method is called in the beginning of the first superstep of the Pregel computation and allows initializing node values.
The interface defines an abstract `compute` method, which is called for each node in every superstep.
Algorithm-specific logic is expressed within the `compute` method.
The context parameter provides access to node properties of the in-memory graph and the algorithm configuration.

The `compute` method is called individually for each node in every superstep as long as the node receives messages or has not voted to halt yet.
Since a Pregel computation is state-less, a node can only communicate with other nodes via messages.
In each superstep, a node receives messages via the input parameter and can send new messages via the context parameter.
Messages can be sent to neighbor nodes or any node if the identifier is known.

The `applyRelationshipWeight` method can be used to modify the message based on a relationship property.
If the input graph has no relationship properties, i.e. is unweighted, the method is skipped.

[[algorithms-pregel-api-java-context]]
=== Init context and compute context

The main purpose of the two context objects is to enable the computation to communicate with the Pregel framework.
A context is stateful, all its methods are subject to the current superstep and the currently processed node.
Both context objects share a set of methods, e.g., to access the config and node state, and add context-specific methods.

The https://github.com/neo-technology/graph-analytics/blob/518a05bf285666c862e9a9db8280e686faeba618/public/core/src/main/java/org/neo4j/graphalgo/beta/pregel/PregelContext.java#L95-L114[InitContext] is available in the `init` method of a Pregel computation.
It provides access to node properties stored in the in-memory graph.
We can set the initial node state to a fixed value, e.g. the node id, or use graph properties and the user-defined configuration to initialize a context-dependent state.

.The InitContext
[source, java]
----
public final class InitContext {
    // The currently processed node id.
    public long nodeId();
    // User-defined Pregel configuration
    public PregelConfig config();
    // Sets a double node value for the given schema key.
    public void setNodeValue(String key, double value);
    // Sets a long node value for the given schema key.
    public void setNodeValue(String key, long value);
    // Number of nodes in the input graph.
    public long nodeCount();
    // Number of relationships in the input graph.
    public long relationshipCount();
    // Number of relationships of the current node.
    public int degree();
    // Available node property keys in the input graph.
    public Set<String> nodePropertyKeys();
    // Node properties stored in the input graph.
    public NodeProperties nodeProperties(String key);
}
----

In contrast, the https://github.com/neo-technology/graph-analytics/blob/518a05bf285666c862e9a9db8280e686faeba618/public/core/src/main/java/org/neo4j/graphalgo/beta/pregel/PregelContext.java#L116-L165[ComputeContext] can be accessed inside the `compute` method.
The context provides methods to access the computation state, e.g. the current superstep, and to send messages to other nodes in the graph.

.The ComputeContext
[source, java]
----
public final class ComputeContext {
    // The currently processed node id.
    public long nodeId();
    // User-defined Pregel configuration
    public PregelConfig config();
    // Sets a double node value for the given schema key.
    public void setNodeValue(String key, double value);
    // Sets a long node value for the given schema key.
    public void setNodeValue(String key, long value);
    // Number of nodes in the input graph.
    public long nodeCount();
    // Number of relationships in the input graph.
    public long relationshipCount();
    // Number of relationships of the current node.
    public int degree();
    // Double value for the given node schema key.
    public double doubleNodeValue(String key);
    // Double value for the given node schema key.
    public long longNodeValue(String key);
    // Notify the framework that the node intends to stop its computation.
    public void voteToHalt();
    // Indicates whether this is the first superstep.
    public boolean isInitialSuperstep();
    // Zero-based superstep identifier.
    public int superstep();
    // Send message to all neighbors of the currently processed node.
    public void sendMessages(double message);
}
----


[[algorithms-pregel-api-java-config]]
=== Configuration

To configure the execution of a custom Pregel computation, the framework requires a configuration.
The `PregelConfiguration` provides the minimum set of options to execute a computation.
The configuration options also map to the parameters that can later be set via a custom procedure.
This is equivalent to all the other algorithms within the GDS library.

.Pregel Configuration
[opts="header",cols="1,1,1,6"]
|===
| Name                      | Type      | Default Value | Description
| maxIterations             | Integer   | -             | Maximum number of supersteps after which the computation will terminate.
| isAsynchronous            | Boolean   | false         | Flag indicating if messages can be sent and received in the same superstep.
| relationshipWeightProperty| String    | null          | Name of the relationship property that represents a relationship weight.
| concurrency               | Integer   | 4             | Concurrency used when executing the Pregel computation.
| writeConcurrency          | Integer   | concurrency   | Concurrency used when writing computation results to Neo4j.
| writeProperty             | String    | "pregel_"     | Prefix string that is prepended to node schema keys in write mode.
| mutateProperty            | String    | "pregel_"     | Prefix string that is prepended to node schema keys in mutate mode.
|===

For some algorithms, we want to specify additional configuration options.

Typically, these options are algorithm specific arguments, such as thresholds.
Another reason for a custom config relates to the initialization phase of the computation.
If we want to init the node state based on a graph property, we need to access that property via its key.
Since those keys are dynamic properties of the graph, we need to provide them to the computation.
We can achieve that by declaring an option to set that key in a custom configuration.

If a user-defined Pregel computation requires custom options a custom configuration can be created by extending the `PregelConfig`.

.A custom configuration and how it can be used in the init phase.
[source, java]
----
@ValueClass
@Configuration
public interface CustomConfig extends PregelConfig {
    // A property key that refers to a seed property.
    String seedProperty();
    // An algorithm specific parameter.
    int minDegree();
}

public class CustomComputation implements PregelComputation<CustomConfig> {

    @Override
    public void init(PregelContext.InitContext<CustomConfig> context) {
        // Use the custom config key to access a graph property.
        var seedProperties = context.nodeProperties(context.config().seedProperty());
        // Init the node state with the graph property for that node.
        context.setNodeValue("state", seedProperties.doubleValue(context.nodeId()));
    }

    @Override
    public void compute(PregelContext.ComputeContext<CustomConfig> context, Pregel.Messages messages) {
        if (context.degree() >= context.config().minDegree()) {
            // ...
        }
    }

    // ...
}
----


[[algorithms-pregel-api-procedure]]
== Exposing a Pregel algorithm via Cypher

To make a custom Pregel computation accessible via Cypher, it needs to be exposed via the procedure API.
The Pregel framework in GDS provides an easy way to generate procedures for all the default modes.

[[algorithms-pregel-api-procedure-generation]]
=== Procedure generation

To generate procedures for a computation, it needs to be annotated with the `@PregelProcedure` annotation.

.Using the `@PregelProcedure` annotation to configure code generation.
[source, java]
----
@PregelProcedure(
    name = "custom.pregel.proc",
    modes = {GDSMode.STREAM, GDSMode.WRITE},
    description = "My custom Pregel algorithm"
)
public class CustomComputation implements PregelComputation<PregelConfig> {
    // ...
}
----

The annotation provides a number of configuration options for the code generation.

.Configuration
[opts="header",cols="1,1,1,6"]
|===
| Name                      | Type      | Default Value                     | Description
| name                      | String    | -                                 | The prefix of the generated procedure name. It is appended by the mode.
| modes                     | List      | `[STREAM, WRITE, MUTATE, STATS]`  | A procedure is generated for each of the specified modes.
| description               | String    | `""`                              | Procedure description that is printed in `dbms.listProcedures()`.
|===

For the above Code snippet, we generate four procedures:

* `custom.pregel.proc.stream`
* `custom.pregel.proc.stream.estimate`
* `custom.pregel.proc.write`
* `custom.pregel.proc.write.estimate`




[[algorithms-pregel-api-plugin]]
=== Building and installing a Neo4j plugin

// TODO talk about the pregel-bootstrap module and the required dependencies

[[algorithms-pregel-api-example]]
== Example

// TODO talk about the example module

.The following provides an example of Pregel computation:
[source, java]
----
import org.neo4j.graphalgo.api.nodeproperties.ValueType;
import org.neo4j.graphalgo.beta.pregel.NodeSchemaBuilder;
import org.neo4j.graphalgo.beta.pregel.Pregel;
import org.neo4j.graphalgo.beta.pregel.PregelComputation;
import org.neo4j.graphalgo.beta.pregel.PregelContext;
import org.neo4j.graphalgo.beta.pregel.annotation.PregelProcedure;

import static org.neo4j.graphalgo.beta.pregel.annotation.GDSMode.MUTATE;
import static org.neo4j.graphalgo.beta.pregel.annotation.GDSMode.STATS;
import static org.neo4j.graphalgo.beta.pregel.annotation.GDSMode.STREAM;
import static org.neo4j.graphalgo.beta.pregel.annotation.GDSMode.WRITE;

@PregelProcedure(
    name = "example.pregel.cc",
    description = "Connected Components",
    modes = {STREAM, WRITE, MUTATE, STATS}
)
public class ConnectedComponentsPregel implements PregelComputation<ConnectedComponentsConfig> {

    public static final String COMPONENT = "component";

    @Override
    public Pregel.NodeSchema nodeSchema() {
        return new NodeSchemaBuilder()
            .putElement(COMPONENT, ValueType.LONG)
            .build();
    }

    @Override
    public void init(PregelContext.InitContext<ConnectedComponentsConfig> context) {
        var initialValue = context.getConfig().seedProperty() != null
            ? context.nodeProperties(context.getConfig().seedProperty()).longValue(context.nodeId())
            : context.nodeId();
        context.setNodeValue(COMPONENT, initialValue);
    }

    @Override
    public void compute(PregelContext.ComputeContext<ConnectedComponentsConfig> context, Pregel.Messages messages) {
        long oldComponentId = context.longNodeValue(COMPONENT);
        long newComponentId = oldComponentId;

        for (var nextComponentId : messages) {
            if (nextComponentId.longValue() < newComponentId) {
                newComponentId = nextComponentId.longValue();
            }
        }

        if (context.isInitialSuperstep() || newComponentId != oldComponentId) {
            context.setNodeValue(COMPONENT, newComponentId);
            context.sendMessages(newComponentId);
        }
    }
}
----
