[[algorithms-ml-linkprediction]]
= Link Prediction
:entity: relationship
:result: relationships
:algorithm: Link Prediction


[abstract]
--
This section describes the Link Prediction Model in the Neo4j Graph Data Science library.
--

This topic includes:

* <<algorithms-ml-linkprediction-intro, Introduction>>
* <<algorithms-ml-linkprediction-syntax, Syntax>>
* <<algorithms-ml-linkprediction-examples, Examples>>
** <<algorithms-ml-linkprediction-examples-train, Train>>
** <<algorithms-ml-linkprediction-examples-mutate, Mutate>>


[[algorithms-ml-linkprediction-intro]]
== Introduction

Link Prediction models are used to predict non-existing relationships between nodes in a graph based on the nodes' properties.
The node properties are used as input features for specific machine learning model candidates.
The model candidates are trained on parts of the input graph and evaluated using a specific metric.
Creating these parts is a necessary pre-processing step called <<algorithms-ml-train-test-splitting>>.

The part of the input graph used for training is called the _train set_.
The part of the input graph used for evaluation is called the _test set_.

The training process follows this outline:

1. The train set is divided into a number of validation folds, consisting of a train part and a validation part.
2. Each model candidate is trained on each train part and evaluated on the respective validation part.
3. The model with the highest average score according to the metric will win the training.
4. The winning model will then be evaluated on the whole train set as well as the test set.
5. The winning model will be registered in the <<model-catalog-ops, Model Catalog>>.

Trained models may then be used to predict the probability of a relationship between two nodes.

[[algorithms-ml-train-test-splitting]]
=== Train/Test Splitting

The Link Prediction training takes as input two relationship types that are used to construct subgraphs representing the parts of the graph used for training and testing, respectively.
Creating these relationship types must be done before training a Link Prediction model.
The relationship types must have a integer property called `label`, with value either `0` or `1`, which denotes a negative or a positive example relationship in the original graph, respectively.

By using the `gds.alpha.ml.splitRelationships()` procedure it is possible to produce the necessary train/test splits.


=== Metrics

The Link Prediction model in the Neo4j GDS library supports only the Area Under the Precision-Recall Curve metric, abbreviated as AUCPR.


[[algorithms-ml-linkprediction-syntax]]
== Syntax

include::../../shared/syntax-intro-named-graph.adoc[]

WARNING: The named graphs must be projected in the `UNDIRECTED` orientation for the Triangle Count algorithm.

.Link Prediction syntax per mode
[.tabbed-example]
====

[.include-with-train]
======
.Run Link Prediction in train mode on a named graph:
[source]
----
CALL gds.alpha.ml.linkPrediction.train(
  graphName: String,
  configuration: Map
) YIELD
  trainMillis: Integer,
  modelInfo: Map,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-train-configuration-named-graph.adoc[]

include::specific-train-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name          | Type    | Description
| trainMillis   | Integer | Milliseconds used for training.
| modelInfo     | Map     | Information about the training and the winning model.
| configuration | Map     | Configuration used for the train procedure.
|===
======


[.include-with-mutate]
======
.Run Link Prediction in mutate mode on a named graph:
[source]
----
CALL gds.alpha.ml.linkPrediction.predict.mutate(
  graphName: String,
  configuration: Map
)
YIELD
  createMillis: Integer,
  computeMillis: Integer,
  postProcessingMillis: Integer,
  mutateMillis: Integer,
  relationshipsWritten: Integer,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-mutate-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                 | Type    | Description
| createMillis         | Integer | Milliseconds for creating the graph.
| computeMillis        | Integer | Milliseconds for running the algorithm.
| postProcessingMillis | Integer | Milliseconds for computing the global metrics.
| mutateMillis         | Integer | Milliseconds for adding properties to the in-memory graph.
| relationshipsWritten | Integer | Number of relationships created.
| configuration        | Map     | Configuration used for running the algorithm.
|===
======
====

[[algorithms-ml-linkprediction-examples]]
== Examples

:algorithm-name: {algorithm}
:graph-description: social network
:image-file: link-prediction.png
include::../../shared/examples-intro.adoc[]

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=setup-query]
----
CREATE
  (alice:Person {name: 'Alice', numberOfPosts: 38}),
  (michael:Person {name: 'Michael', numberOfPosts: 67}),
  (karin:Person {name: 'Karin', numberOfPosts: 30}),
  (chris:Person {name: 'Chris', numberOfPosts: 132}),
  (will:Person {name: 'Will', numberOfPosts: 6}),
  (mark:Person {name: 'Mark', numberOfPosts: 32}),
  (greg:Person {name: 'Greg', numberOfPosts: 29}),
  (veselin:Person {name: 'Veselin', numberOfPosts: 3}),

  (alice)-[:KNOWS]->(michael),
  (michael)-[:KNOWS]->(karin),
  (michael)-[:KNOWS]->(chris),
  (michael)-[:KNOWS]->(greg),
  (will)-[:KNOWS]->(michael),
  (will)-[:KNOWS]->(chris),
  (mark)-[:KNOWS]->(michael),
  (mark)-[:KNOWS]->(will),
  (greg)-[:KNOWS]->(chris),
  (veselin)-[:KNOWS]->(chris),
  (karin)-[:KNOWS]->(veselin),
  (chris)-[:KNOWS]->(karin)
----

With the graph in Neo4j we can now project it into the graph catalog to prepare it for algorithm execution.
We do this using a native projection targeting the `Person` nodes and the `KNOWS` relationships.
We will also project the `numberOfPosts` property so we can use it as a model feature.
For the relationships we must use the `UNDIRECTED` orientation.
This is because the Link Prediction model is defined only for undirected graphs.

include::../../shared/examples-named-native-note.adoc[]

.The following statement will create a graph using a native projection and store it in the graph catalog under the name 'myGraph'.
[source, cypher, role=graph-create-query]
----
CALL gds.graph.create(
  'myGraph',
  {
    Person: {
      properties: ['numberOfPosts']
    }
  },
  {
    KNOWS: {
      orientation: 'UNDIRECTED'
    }
  }
)
----

WARNING: The Link Prediction model requires the graph to be created using the `UNDIRECTED` orientation for relationships.

In the following examples we will demonstrate using the Link Prediction model on this graph.


[[algorithms-ml-linkprediction-examples-train]]
=== Train

First, we must do the test/train splits.
For this we will make use of the `gds.alpha.ml.splitRelationships` procedure.
We will do one split to select relationships to be used in the test set.

[source, cypher, role=example-query]
----
CALL gds.alpha.ml.splitRelationships.mutate('myGraph', {
  relationshipTypes: ['KNOWS'],
  remainingRelationshipType: 'KNOWS_REMAINING',
  holdoutRelationshipType: 'KNOWS_TESTSET',
  holdoutFraction: 0.2
}) YIELD relationshipsWritten
----

.Results
[opts="header"]
|===
| relationshipsWritten
| 24
|===

We will create copied relationships for each existing relationship, into either the `KNOWS_REMAINING` or the `KNOWS_TESTSET` relationship types.
All relationships in `KNOWS_TESTSET` will have a `label` property.
Additionally, a number of non-existing relationships will be created into the `KNOWS_TESTSET` relationship type to be used as negative examples, with a `label` of `0`.

Next, we will create the train set.

[source, cypher, role=example-query]
----
CALL gds.alpha.ml.splitRelationships.mutate('myGraph', {
  relationshipTypes: ['KNOWS_REMAINING'],
  remainingRelationshipType: 'KNOWS_IGNORED_FOR_TRAINING',
  holdoutRelationshipType: 'KNOWS_TRAINSET',
  holdoutFraction: 0.2
}) YIELD relationshipsWritten
----

.Results
[opts="header"]
|===
| relationshipsWritten
| 20
|===

With both train and test sets, we are ready to train models.

[source, cypher, role=example-query]
----
CALL gds.alpha.ml.linkPrediction.train('myGraph', {
  trainRelationshipType: 'KNOWS_TRAINSET',
  testRelationshipType: 'KNOWS_TESTSET',
  modelName: 'model',
  featureProperties: ['numberOfPosts'],
  validationFolds: 5,
  classRatio: 0.88,
  randomSeed: 2,
  params: [
    {penalty: 0.5, maxIterations: 1000},
    {penalty: 1.0, maxIterations: 1000},
    {penalty: 0.0, maxIterations: 1000}
  ]
}) YIELD modelInfo
RETURN modelInfo.bestParameters AS winningModel
----

.Results
[opts="header"]
|===
| winningModel
| {maxIterations: 1000, penalty: 0.5}
|===


[[algorithms-ml-linkprediction-examples-mutate]]
=== Mutate

//TODO