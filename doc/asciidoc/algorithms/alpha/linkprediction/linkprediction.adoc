[[algorithms-ml-linkprediction]]
= Link Prediction
:entity: relationship
:result: relationships
:algorithm: Link Prediction


[abstract]
--
This section describes the Link Prediction Model in the Neo4j Graph Data Science library.
--

This topic includes:

* <<algorithms-ml-linkprediction-intro, Introduction>>
* <<algorithms-ml-linkprediction-syntax, Syntax>>
* <<algorithms-ml-linkprediction-examples, Examples>>
** <<algorithms-ml-linkprediction-examples-train, Train>>
** <<algorithms-ml-linkprediction-examples-mutate, Mutate>>


[[algorithms-ml-linkprediction-intro]]
== Introduction

Link prediction is a common machine learning task applied to graphs: training a model to learn, between pairs of nodes in a graph, where relationships should exist.
You can think of this as building a model to predict missing relationships in your dataset or relationships that are likely to form in the future.
Neo4j GDS trains supervised machine learning models based on the relationships and properties in your graph to predict the existence - and probability - of relationships.

Link Prediction models are used to predict non-existing relationships between nodes in a graph based on the nodes' properties.
The specified node properties are used as input features.
Models are trained on parts of the input graph and evaluated using a specific metric.
The first step, before training the model, is <<algorithms-ml-train-test-splitting, splitting the graph into a train and a test graph>>, so the test graph may be used to evaluate model performance.

Following splitting the data, the training process follows this outline:

1. The train graph is divided into a number of validation folds, consisting of a train part and a validation part.
2. Each model candidate is trained on each train part and evaluated on the respective validation part.
3. The training process uses a logistic regression algorithm, and the evaluation uses the <<algorithms-ml-metrics, AUCPR metric>>.
4. The model with the highest average score according to the metric will win the training.
5. The winning model will then be evaluated on the whole train graph as well as the test graph.
6. The winning model will be registered in the <<model-catalog-ops, Model Catalog>>.

Trained models may then be used to predict the probability of a relationship between two nodes.


[[algorithms-ml-train-test-splitting]]
=== Train/Test Splitting

The Link Prediction training takes as input two relationship types that are used to construct subgraphs representing the parts of the graph used for training and testing, respectively.
Creating these relationship types must be done before training a Link Prediction model.
The relationship types must have a integer property called `label`, with value either `0` or `1`, which denotes a negative or a positive example relationship in the original graph, respectively.

By using the `gds.alpha.ml.splitRelationships()` procedure it is possible to produce the necessary train/test splits.


[[algorithms-ml-metrics]]
=== Metrics

The Link Prediction model in the Neo4j GDS library supports only the Area Under the Precision-Recall Curve metric, abbreviated as AUCPR.


[[algorithms-ml-linkprediction-syntax]]
== Syntax

include::../../shared/syntax-intro-named-graph.adoc[]

WARNING: The named graphs must be projected in the `UNDIRECTED` orientation for the Link Prediction model.

.Link Prediction syntax per mode
[.tabbed-example]
====

[.include-with-train]
======
.Run Link Prediction in train mode on a named graph:
[source]
----
CALL gds.alpha.ml.linkPrediction.train(
  graphName: String,
  configuration: Map
) YIELD
  trainMillis: Integer,
  modelInfo: Map,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-train-configuration-named-graph.adoc[]

include::specific-train-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name          | Type    | Description
| trainMillis   | Integer | Milliseconds used for training.
| modelInfo     | Map     | Information about the training and the winning model.
| configuration | Map     | Configuration used for the train procedure.
|===
======


[.include-with-mutate]
======
.Run Link Prediction in mutate mode on a named graph:
[source]
----
CALL gds.alpha.ml.linkPrediction.predict.mutate(
  graphName: String,
  configuration: Map
)
YIELD
  createMillis: Integer,
  computeMillis: Integer,
  postProcessingMillis: Integer,
  mutateMillis: Integer,
  relationshipsWritten: Integer,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

include::../../common-configuration/common-mutate-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                 | Type    | Description
| createMillis         | Integer | Milliseconds for creating the graph.
| computeMillis        | Integer | Milliseconds for running the algorithm.
| postProcessingMillis | Integer | Milliseconds for computing the global metrics.
| mutateMillis         | Integer | Milliseconds for adding properties to the in-memory graph.
| relationshipsWritten | Integer | Number of relationships created.
| configuration        | Map     | Configuration used for running the algorithm.
|===
======
====

[[algorithms-ml-linkprediction-examples]]
== Examples

:algorithm-name: {algorithm}
:graph-description: social network
:image-file: link-prediction.svg
include::../../shared/examples-intro.adoc[]

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=setup-query]
----
CREATE
  (alice:Person {name: 'Alice', numberOfPosts: 38}),
  (michael:Person {name: 'Michael', numberOfPosts: 67}),
  (karin:Person {name: 'Karin', numberOfPosts: 30}),
  (chris:Person {name: 'Chris', numberOfPosts: 132}),
  (will:Person {name: 'Will', numberOfPosts: 6}),
  (mark:Person {name: 'Mark', numberOfPosts: 32}),
  (greg:Person {name: 'Greg', numberOfPosts: 29}),
  (veselin:Person {name: 'Veselin', numberOfPosts: 3}),

  (alice)-[:KNOWS]->(michael),
  (michael)-[:KNOWS]->(karin),
  (michael)-[:KNOWS]->(chris),
  (michael)-[:KNOWS]->(greg),
  (will)-[:KNOWS]->(michael),
  (will)-[:KNOWS]->(chris),
  (mark)-[:KNOWS]->(michael),
  (mark)-[:KNOWS]->(will),
  (greg)-[:KNOWS]->(chris),
  (veselin)-[:KNOWS]->(chris),
  (karin)-[:KNOWS]->(veselin),
  (chris)-[:KNOWS]->(karin);
----

With the graph in Neo4j we can now project it into the graph catalog to prepare it for algorithm execution.
We do this using a native projection targeting the `Person` nodes and the `KNOWS` relationships.
We will also project the `numberOfPosts` property so we can use it as a model feature.
For the relationships we must use the `UNDIRECTED` orientation.
This is because the Link Prediction model is defined only for undirected graphs.

include::../../shared/examples-named-native-note.adoc[]

.The following statement will create a graph using a native projection and store it in the graph catalog under the name 'myGraph'.
[source, cypher, role=graph-create-query]
----
CALL gds.graph.create(
  'myGraph',
  {
    Person: {
      properties: ['numberOfPosts']
    }
  },
  {
    KNOWS: {
      orientation: 'UNDIRECTED'
    }
  }
)
----

WARNING: The Link Prediction model requires the graph to be created using the `UNDIRECTED` orientation for relationships.

In the following examples we will demonstrate using the Link Prediction model on this graph.


[[algorithms-ml-linkprediction-examples-train]]
=== Train

First, we must do the test/train splits.
For this we will make use of the `gds.alpha.ml.splitRelationships` procedure.
We will do one split to select relationships to be used in the test graph.

[source, cypher, role=example-query]
----
CALL gds.alpha.ml.splitRelationships.mutate('myGraph', {
  relationshipTypes: ['KNOWS'],
  remainingRelationshipType: 'KNOWS_REMAINING',
  holdoutRelationshipType: 'KNOWS_TESTGRAPH',
  holdoutFraction: 0.2
}) YIELD relationshipsWritten
----

.Results
[opts="header"]
|===
| relationshipsWritten
| 24
|===

We will create copied relationships for each existing relationship, into either the `KNOWS_REMAINING` or the `KNOWS_TESTGRAPH` relationship types.
All relationships in `KNOWS_TESTGRAPH` will have a `label` property.
Additionally, a number of non-existing relationships will be created into the `KNOWS_TESTGRAPH` relationship type to be used as negative examples, with a `label` of `0`.

Next, we will create the train graph.

[source, cypher, role=example-query]
----
CALL gds.alpha.ml.splitRelationships.mutate('myGraph', {
  relationshipTypes: ['KNOWS_REMAINING'],
  remainingRelationshipType: 'KNOWS_IGNORED_FOR_TRAINING',
  holdoutRelationshipType: 'KNOWS_TRAINGRAPH',
  holdoutFraction: 0.2
}) YIELD relationshipsWritten
----

.Results
[opts="header"]
|===
| relationshipsWritten
| 20
|===

With both train and test graphs, we are ready to train models.
We will use 5 validation folds, meaning we will split the train graph into 5 pairs, using one part of each pair for training and one for validation.
We set the class ratio to 1.33, which is calculated as the number of non-existing relationships over the number of existing relationships.
In our graph we have 8 nodes, which gives us a maximum of `8 * 7 / 2 = 28` undirected relationships.
We have 12 actual relationships, giving us a class ratio of `(28 - 12) / 12 = 1.33`.

[[algorithms-ml-linkprediction-examples-train-query]]
[source, cypher, role=example-query]
----
CALL gds.alpha.ml.linkPrediction.train('myGraph', {
  trainRelationshipType: 'KNOWS_TRAINGRAPH',
  testRelationshipType: 'KNOWS_TESTGRAPH',
  modelName: 'lp-numberOfPosts-model',
  featureProperties: ['numberOfPosts'],
  validationFolds: 5,
  classRatio: 1.33,
  randomSeed: 2,
  params: [
    {penalty: 0.5, maxIterations: 1000},
    {penalty: 1.0, maxIterations: 1000},
    {penalty: 0.0, maxIterations: 1000}
  ]
}) YIELD modelInfo
RETURN
  modelInfo.bestParameters AS winningModel,
  modelInfo.metrics.AUCPR.outerTrain AS trainGraphScore,
  modelInfo.metrics.AUCPR.test AS testGraphScore
----

.Results
[opts="header"]
|===
| winningModel                        | trainGraphScore    | testGraphScore
| {maxIterations: 1000, penalty: 0.5} | 0.7145922746781116 | 0.3512042965360351
|===

Here we can observe that the model candidate with penalty 0.5 performed the best in the training phase, with a score of about 71% over the train graph.
On the test graph, the model scored much lower at about 35%.
This indicates that the model reacted fairly well to the train graph, but did not generalise very well to unseen data.
In order to achieve a higher test score, we may need to use better features, a larger graph, or different model configuration.


[[algorithms-ml-linkprediction-examples-mutate]]
=== Mutate

In this example we will show how to use a trained model to predict new relationships in your in-memory graph.
In order to do this, we must first have an already trained model registered in the Model Catalog.
We will use the model which we trained in the <<algorithms-ml-linkprediction-examples-train-query, train example>> which we gave the name `'lp-numberOfPosts-model'`.

We must also make sure that we do not include any of the relationships from the train or test graphs, which we do by specifying a relationship filter for the original relationship type `'KNOWS'`.

[source, cypher, role=example-query]
----
CALL gds.alpha.ml.linkPrediction.predict.mutate('myGraph', {
  relationshipTypes: ['KNOWS'],
  modelName: 'lp-numberOfPosts-model',
  mutateRelationshipType: 'KNOWS_PREDICTED',
  topN: 5,
  threshold: 0.45
}) YIELD relationshipsWritten
----

.Results
[opts="header"]
|===
| relationshipsWritten
| 10
|===

We specified to get the top 5 relationships for which the predicted probability was greater than 45%.
Because we are using the `UNDIRECTED` orientation, we will write twice as many relationships to the in-memory graph.

In order to analyse our predicted relationships we will write them back to Neo4j:

[source, cypher, role=example-query]
----
CALL gds.graph.writeRelationship('myGraph', 'KNOWS_PREDICTED', 'probability')
YIELD relationshipsWritten, propertiesWritten
----

.Results
[opts="header"]
|===
| relationshipsWritten | propertiesWritten
| 10                   | 10
|===

The end result looks like this:

image::example-graphs/link-prediction-mutate.svg[align="center"]

In yellow we highlight the predicted relationships.
