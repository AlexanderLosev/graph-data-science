[[algorithms-split-relationships]]
[.alpha]
= Split Relationships

[abstract]
--
This section describes the Split Relationships algorithm in the Neo4j Graph Data Science library.
--

This topic includes:

* <<algorithms-split-relationships-intro, Introduction>>
* <<algorithms-split-relationships-syntax, Syntax>>
* <<algorithms-split-relationships-examples, Examples>>

[[algorithms-split-relationships-intro]]
== Introduction

The Split relationships algorithm is a utility algorithm that is used to pre-process a graph for model training.
It splits the relationship set into a hold-out (test) and a remaining (train) set of relationships.
The hold-out set is divided into two classes: positive, i.e., existing relationships, and negative, i.e., non-existing relationships.
The class affiliation is indicated by a `label` property on the relationships.
Both, the hold-out and the remaining relationships are added to the in-memory graph.


[[algorithms-split-relationships-syntax]]
== Syntax

.Split Relationships syntax per mode
[.tabbed-example]
====

[.include-with-mutate]
======
.Run Split Relationships in mutate mode on a named graph.
[source, cypher]
----
CALL gds.alpha.ml.splitRelationships.mutate(
  graphName: String,
  configuration: Map
)
YIELD
  createMillis: Integer,
  computeMillis: Integer,
  mutateMillis: Integer,
  relationshipsWritten: Integer,
  configuration: Map
----

include::../../common-configuration/common-parameters-named-graph.adoc[]

.General configuration for algorithm execution on a named graph.
[opts="header",cols="1,1,1m,1,4"]
|===
| Name              | Type     | Default | Optional | Description
| nodeLabels        | String[] | ['*']   | yes      | Filter the named graph using the given node labels.
| relationshipTypes | String[] | ['*']   | yes      | Filter the named graph using the given relationship types.
| concurrency       | Integer  | 4       | yes      | The number of concurrent threads used for running the algorithm.
|===

.Algorithm specific configuration
[opts="header",cols="1,1,1m,1,4"]
|===
| Name                          | Type          | Default         | Optional  | Description
| holdoutFraction               | Float         | n/a             | no        | The fraction of all relationships being used as hold-out set.
| holdoutRelationshipType       | String        | n/a             | no        | Indicates relationships that are part of the hold-out set. Each relationship has a relationship property `label` that indicates relationship existence.
| remainingRelationshipType     | String        | n/a             | no        | Indicates relationships that have not been selected during sampling.
| nonNegativeRelationshipTypes  | String[]      | n/a             | yes       | Additional relationship types that are used for negative sampling.
| randomSeed                    | Integer       | n/a             | yes       | An optional seed value for the random selection of relationships.
|===

.Results
[opts="header",cols="1m,1,6"]
|===
| Name                  | Type      | Description
| createMillis          | Integer   | Milliseconds for loading data.
| computeMillis         | Integer   | Milliseconds for running the algorithm.
| mutateMillis          | Integer   | Milliseconds for adding properties to the in-memory graph.
| relationshipsWritten  | Integer   | The number of relationships created by the algorithm.
| configuration         | Map       | The configuration used for running the algorithm.
|===
======
====

[[algorithms-split-relationships-examples]]
== Examples

Consider the graph created by the following Cypher statement:

[source, cypher, role=setup-query]
----
CREATE
    (n0:Label),
    (n1:Label),
    (n2:Label),
    (n3:Label),
    (n4:Label),
    (n5:Label),

    (n0)-[:TYPE]->(n1),
    (n1)-[:TYPE]->(n2),
    (n2)-[:TYPE]->(n3),
    (n3)-[:TYPE]->(n4),
    (n4)-[:TYPE]->(n5)
----

Given the above graph, we want to use 20% of the relationships as hold-out set.
The hold-out set will be split into two same-sized classes: positive and negative.
Positive relationships will be randomly selected from the existing relationships and marked with a property `label: 1`.
Negative relationships will be randomly generated, i.e., they do not exist in the input graph, and are marked with a property `label: 0`.

[source, cypher, role=graph-create-query]
----
CALL gds.graph.create(
    'graph',
    '*',
    { TYPE: {type: 'TYPE', orientation: 'UNDIRECTED'} }
)
----

Now we can run the algorithm by specifying the appropriate ratio and the output relationship types.
We use a random seed value in order to produce deterministic results.

[role=query-example]
--
[source, cypher]
----
CALL gds.alpha.ml.splitRelationships.mutate('graph', {
    holdoutRelationshipType: 'TEST',
    remainingRelationshipType: 'TRAIN',
    holdoutFraction: 0.2,
    randomSeed: 1337
}) YIELD relationshipsWritten
----

[opts=header]
.Results
|===
| relationshipsWritten
| 10
|===
--

The input graph consists of 5 relationships.
Since the graph is created with orientation `UNDIRECTED`, the in-memory graph has 10 relationships.
We use 20% of the relationship count as hold-out set.
50% of those (1 relationship) are selected from the existing relationships and classified as positive.
The other 50% (1 relationship) are created and do not exist in the input graph.

.The mutated graph will look like the following graph when filtered by the `TEST` and `TRAIN` relationship.
[source, cypher]
----
CREATE
    (n0:Label),
    (n1:Label),
    (n2:Label),
    (n3:Label),
    (n4:Label),
    (n5:Label),

    (n2)-[:TEST { label: 0 }]->(n5), // negative, non-existing
    (n3)-[:TEST { label: 1 }]->(n2), // positive, existing

    (n0)<-[:TRAIN]-(n1),
    (n1)<-[:TRAIN]-(n2),
    (n3)<-[:TRAIN]-(n4),
    (n4)<-[:TRAIN]-(n5),
    (n0)-[:TRAIN]->(n1),
    (n1)-[:TRAIN]->(n2),
    (n3)-[:TRAIN]->(n4),
    (n4)-[:TRAIN]->(n5)
----
