[[algorithms-betweenness-centrality]]
= Betweenness Centrality
:entity: node
:result: centrality
:algorithm: Betweenness Centrality

[abstract]
--
This section describes the Betweenness Centrality algorithm in the Neo4j Graph Data Science library.
--

This topic includes:

* <<algorithms-betweenness-centrality-intro, Introduction>>
* <<algorithms-betweenness-centrality-considerations, Considerations and sampling>>
* <<algorithms-betweenness-centrality-syntax, Syntax>>
** <<algorithms-betweenness-centrality-syntax-stream, Stream>>
** <<algorithms-betweenness-centrality-syntax-stats, Stats>>
** <<algorithms-betweenness-centrality-syntax-mutate, Mutate>>
** <<algorithms-betweenness-centrality-syntax-write, Write>>
** <<algorithms-betweenness-centrality-syntax-anonymous, Anonymous graphs>>
* <<algorithms-betweenness-centrality-examples, Examples>>
** <<algorithms-betweenness-centrality-examples-memory-estimation, Memory Estimation>>
** <<algorithms-betweenness-centrality-examples-stream, Stream>>
** <<algorithms-betweenness-centrality-examples-stats, Stats>>
** <<algorithms-betweenness-centrality-examples-mutate, Mutate>>
** <<algorithms-betweenness-centrality-examples-write, Write>>


[[algorithms-betweenness-centrality-intro]]
== Introduction

Betweenness centrality is a way of detecting the amount of influence a node has over the flow of information in a graph.
It is often used to find nodes that serve as a bridge from one part of a graph to another.

The algorithm calculates the shortest paths between all pairs of nodes in an unweighted graph.
Each node receives a score, based on the number of shortest paths that pass through the node.
Nodes that more frequently lie on shortest paths between other nodes will have higher betweenness centrality scores.

The GDS implementation is based on https://www.uni-konstanz.de/mmsp/pubsys/publishedFiles/BrPi07.pdf[Brandes' approximate algorithm^] for unweighted graphs.
The implementation requires _O(n + m)_ space and runs in _O(n * m)_ time, where _n_ is the number of nodes and _m_ the number of relationships in the graph.

For more information on this algorithm, see:

* https://www.eecs.wsu.edu/~assefaw/CptS580-06/papers/brandes01centrality.pdf[A Faster Algorithm for Betweenness Centrality^]
* https://www.uni-konstanz.de/mmsp/pubsys/publishedFiles/BrPi07.pdf[Centrality Estimation in Large Networks^]
* http://moreno.ss.uci.edu/23.pdf[A Set of Measures of Centrality Based on Betweenness^]

[NOTE]
====
Running this algorithm requires sufficient memory availability.
Before running this algorithm, we recommend that you read <<memory-estimation>>.
====


[[algorithms-betweenness-centrality-considerations]]
== Considerations and sampling

The Betweenness Centrality algorithm can be very resource-intensive to compute.
https://www.uni-konstanz.de/mmsp/pubsys/publishedFiles/BrPi07.pdf[Brandes' approximate algorithm^] computes single-source shortest paths (SSSP) for a set of source nodes.
When all nodes are selected as source nodes, the algorithm produces an exact result.
However, for large graphs this can potentially lead to very long runtimes.
Thus, approximating the results by computing the SSSPs for only a subset of nodes can be useful.
In GDS we refer to this technique as _sampling_, where the size of the source node set is the _sampling size_.

There are two things to consider when executing the algorithm on large graphs:

* A higher parallelism leads to higher memory consumption as each thread executes SSSPs for a subset of source nodes sequentially.
** In the worst case, a single SSSP requires the whole graph to be duplicated in memory.
* A higher sampling size leads to more accurate results, but also to a potentially much longer execution time.

Changing the values of the configuration parameters `concurrency` and `samplingSize`, respectively, can help to manage these considerations.


[[algorithms-betweenness-centrality-sampling-strategies]]
=== Sampling strategies

Brandes defines several strategies for selecting source nodes.
The GDS implementation is based on the random degree selection strategy, which selects nodes with a probability proportional to their degree.
The idea behind this strategy is that such nodes are likely to lie on many shortest paths in the graph and thus have a higher contribution to the betweenness centrality score.


[[algorithms-betweenness-centrality-syntax]]
== Syntax

include::../shared/syntax-intro-named-graph.adoc[]

[[algorithms-betweenness-centrality-syntax-stream]]
=== Stream

.Run Betweenness Centrality in stream mode on a named graph.
[source, cypher]
----
CALL gds.betweenness.stream(
  graphName: String,
  configuration: Map
)
YIELD
  nodeId: Integer,
  score: Float
----

include::../common-configuration/common-parameters-named-graph.adoc[]

include::../common-configuration/common-stream-stats-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header"]
|===
| Name   | Type    | Description
| nodeId | Integer | Node ID.
| score  | Float   | Betweenness Centrality score.
|===


[[algorithms-betweenness-centrality-syntax-stats]]
=== Stats

.Run Betweenness Centrality in stats mode on a named graph.
[source, cypher]
----
CALL gds.betweenness.stats(
  graphName: String,
  configuration: Map
)
YIELD
  minCentrality: Float,
  maxCentrality: Float,
  sumCentrality: Float,
  createMillis: Integer,
  computeMillis: Integer,
  configuration: Map
----

include::../common-configuration/common-parameters-named-graph.adoc[]

include::../common-configuration/common-stream-stats-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name          | Type    | Description
| minCentrality | Float   | Lowest centrality score.
| maxCentrality | Float   | Greatest centrality score.
| sumCentrality | Float   | Sum of all centrality scores.
| createMillis  | Integer | Milliseconds for creating the graph.
| computeMillis | Integer | Milliseconds for running the algorithm.
| configuration | Map     | Configuration used for running the algorithm.
|===


[[algorithms-betweenness-centrality-syntax-mutate]]
=== Mutate

.Run Betweenness Centrality in mutate mode on a graph stored in the catalog.
[source, cypher]
----
CALL gds.betweenness.mutate(
  graphName: String,
  configuration: Map
)
YIELD
  minCentrality: Float,
  maxCentrality: Float,
  sumCentrality: Float,
  createMillis: Integer,
  computeMillis: Integer,
  mutateMillis: Integer,
  nodePropertiesWritten: Integer,
  configuration: Map
----

include::../common-configuration/common-parameters-named-graph.adoc[]

include::../common-configuration/common-mutate-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                  | Type    | Description
| minCentrality         | Float   | Lowest centrality score.
| maxCentrality         | Float   | Greatest centrality score.
| sumCentrality         | Float   | Sum of all centrality scores.
| createMillis          | Integer | Milliseconds for creating the graph.
| computeMillis         | Integer | Milliseconds for running the algorithm.
| mutateMillis          | Integer | Milliseconds for adding properties to the in-memory graph.
| nodePropertiesWritten | Integer | Number of properties added to the in-memory graph.
| configuration         | Map     | Configuration used for running the algorithm.
|===


[[algorithms-betweenness-centrality-syntax-write]]
=== Write

.Run Betweenness Centrality in write mode on a named graph.
[source, cypher]
----
CALL gds.betweenness.write(
  graphName: String,
  configuration: Map
)
YIELD
  minCentrality: Float,
  maxCentrality: Float,
  sumCentrality: Float,
  createMillis: Integer,
  computeMillis: Integer,
  writeMillis: Integer,
  nodePropertiesWritten: Integer,
  configuration: Map
----

include::../common-configuration/common-parameters-named-graph.adoc[]

include::../common-configuration/common-write-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                   | Type    | Description
| minCentrality          | Float   | Lowest centrality score.
| maxCentrality          | Float   | Highest centrality score.
| sumCentrality          | Float   | Sum of all centrality scores.
| createMillis           | Integer | Milliseconds for creating the graph.
| computeMillis          | Integer | Milliseconds for running the algorithm.
| writeMillis            | Integer | Milliseconds for writing result data back.
| nodePropertiesWritten  | Integer | Number of properties written to Neo4j.
| configuration          | Map     | The configuration used for running the algorithm.
|===


[[algorithms-betweenness-centrality-syntax-anonymous]]
=== Anonymous graphs

include::../shared/syntax-anonymous-graphs.adoc[]

.Run Betweenness Centrality in write mode on an anonymous graph:
[source, cypher]
----
CALL gds.betweenness.write(
  configuration: Map
)
YIELD
  minCentrality: Float,
  maxCentrality: Float,
  sumCentrality: Float,
  createMillis: Integer,
  computeMillis: Integer,
  writeMillis: Integer,
  nodePropertiesWritten: Integer,
  configuration: Map
----

include::../common-configuration/common-write-configuration-anonymous-graph.adoc[]

include::specific-configuration.adoc[]

The results are the same as for running write mode with a named graph, <<algorithms-betweenness-centrality-syntax-write, specified above>>.


[[algorithms-betweenness-centrality-examples]]
== Examples

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=setup-query]
----
CREATE
  (home:Page {name:'Home'}),
  (about:Page {name:'About'}),
  (product:Page {name:'Product'}),
  (links:Page {name:'Links'}),
  (a:Page {name:'Site A'}),
  (b:Page {name:'Site B'}),
  (c:Page {name:'Site C'}),
  (d:Page {name:'Site D'}),

  (home)-[:LINKS {weight: 0.2}]->(about),
  (home)-[:LINKS {weight: 0.2}]->(links),
  (home)-[:LINKS {weight: 0.6}]->(product),
  (about)-[:LINKS {weight: 1.0}]->(home),
  (product)-[:LINKS {weight: 1.0}]->(home),
  (a)-[:LINKS {weight: 1.0}]->(home),
  (b)-[:LINKS {weight: 1.0}]->(home),
  (c)-[:LINKS {weight: 1.0}]->(home),
  (d)-[:LINKS {weight: 1.0}]->(home),
  (links)-[:LINKS {weight: 0.8}]->(home),
  (links)-[:LINKS {weight: 0.05}]->(a),
  (links)-[:LINKS {weight: 0.05}]->(b),
  (links)-[:LINKS {weight: 0.05}]->(c),
  (links)-[:LINKS {weight: 0.05}]->(d);
----

This graph represents eight pages, linking to one another.
Each relationship has a property called `weight`, which describes the importance of the relationship.

include::../shared/examples-named-native-note.adoc[]

.The following statement will create a graph using a native projection and store it in the graph catalog under the name 'myGraph'.
[source, cypher, role=graph-create-query]
----
CALL gds.graph.create(
  'myGraph',
  'Page',
  'LINKS',
  {
    relationshipProperties: 'weight'
  }
)
----


[[algorithms-betweenness-centrality-examples-memory-estimation]]
=== Memory Estimation

:mode: write
include::../shared/examples-estimate-intro.adoc[]

[role=query-example]
--
.The following will estimate the memory requirements for running the algorithm:
[source, cypher]
----
CALL gds.betweenness.write.estimate('myGraph', { writeProperty: 'centrality' })
YIELD nodeCount, relationshipCount, bytesMin, bytesMax, requiredMemory
----

.Results
[opts="header",cols="1,1,1,1,1"]
|===
| nodeCount | relationshipCount | bytesMin | bytesMax | requiredMemory
| 8         | 14                | 1560     | 1560     | "1560 Bytes"
|===
--


[[algorithms-betweenness-centrality-examples-stream]]
=== Stream

:stream-details: For example, we can order the results to find the nodes with the highest PageRank centrality.
include::../shared/examples-stream-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm in `stream` mode:
[source, cypher]
----
CALL gds.betweenness.stream('myGraph')
YIELD nodeId, centrality
RETURN gds.util.asNode(nodeId).name AS name, centrality
ORDER BY centrality DESC, name ASC
----

.Results
[opts="header",cols="1,1"]
|===
| name      | centrality
| "Home"    | 3.2362017153762284
| "About"   | 1.0611098567023873
| "Links"   | 1.0611098567023873
| "Product" | 1.0611098567023873
| "Site A"  | 0.3292259009438567
| "Site B"  | 0.3292259009438567
| "Site C"  | 0.3292259009438567
| "Site D"  | 0.3292259009438567
|===
--

[[algorithms-betweenness-centrality-examples-stats]]
=== Stats

:stats-details: For example Betweenness Centrality stats returns minimum, maximum and the sum of all centrality values.
:stats-syntax: algorithms-betweenness-centrality-syntax-stats
include::../shared/examples-stats-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm and returns the result in form of statistical and measurement values
[source, cypher]
----
CALL gds.betweenness.stats('myGraph')
YIELD minCentrality, maxCentrality, sumCentrality
RETURN minCentrality, maxCentrality, sumCentrality
----

.Results
[opts="header",cols="1"]
|===
| max
| 3.236204147338867
|===
--

[[algorithms-betweenness-centrality-examples-mutate]]
=== Mutate

include::../shared/examples-mutate-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm in `mutate` mode:
[source, cypher]
----
CALL gds.betweenness.mutate('myGraph', { mutateProperty: 'centrality' })
YIELD nodePropertiesWritten
----

.Results
[opts="header",cols="1m"]
|===
| nodePropertiesWritten
| 8
|===
--


[[algorithms-betweenness-centrality-examples-write]]
=== Write

include::../shared/examples-write-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm in `write` mode:
[source, cypher]
----
CALL gds.betweenness.write('myGraph', { writeProperty: 'centrality' })
YIELD nodePropertiesWritten
----

.Results
[opts="header",cols="1m"]
|===
| nodePropertiesWritten
| 8
|===
--
