[[algorithms-triangle-count]]
= Triangle Count
:entity: node
:result: triangle count

[abstract]
--
This section describes the Triangle Count algorithm in the Neo4j Graph Data Science library.
--

This topic includes:

* <<algorithms-triangle-count-intro, Introduction>>
* <<algorithms-triangle-count-syntax, Syntax>>
** <<algorithms-triangle-count-syntax-stream, Stream>>
** <<algorithms-triangle-count-syntax-stats, Stats>>
** <<algorithms-triangle-count-syntax-mutate, Mutate>>
** <<algorithms-triangle-count-syntax-write, Write>>
* <<algorithms-triangle-count-examples, Examples>>
** <<algorithms-triangle-count-examples-memory-estimation, Memory Estimation>>
** <<algorithms-triangle-count-examples-stream, Stream>>
** <<algorithms-triangle-count-examples-stats, Stats>>
** <<algorithms-triangle-count-examples-mutate, Mutate>>
** <<algorithms-triangle-count-examples-write, Write>>
** <<algorithms-triangle-count-examples-max-degree, Maximum degree>>


[[algorithms-triangle-count-intro]]
== Introduction

The Triangle Count algorithm counts the number of triangles for each node in the graph.
A triangle is a set of three nodes where each node has a relationship to the other two.
In graph theory terminology, this is sometimes referred to as a 3-clique.
The Triangle Count algorithm in the GDS library only finds triangles in undirected graphs.

Triangle counting has gained popularity in social network analysis, where it is used to detect communities and measure the cohesiveness of those communities.
It can also be used to determine the stability of a graph, and is often used as part of the computation of network indices, such as clustering coefficients.
The Triangle Count algorithm is also used to compute the <<algorithms-local-clustering-coefficient, Local Clustering Coefficient>>.

For more information on this algorithm, see:

* Triangle count and clustering coefficient have been shown to be useful as features for classifying a given website as spam, or non-spam, content.
This is described in http://chato.cl/papers/becchetti_2007_approximate_count_triangles.pdf["Efficient Semi-streaming Algorithms for Local Triangle Counting in Massive Graphs"].


[[algorithms-triangle-count-syntax]]
== Syntax

This section covers the syntax used to execute the Triangle Count algorithm in each of its execution modes.
The named graph variant of the syntax is described.
To learn more about general syntax variants, see <<algorithms-syntax>>.

WARNING: The named graphs must be projected in the `UNDIRECTED` orientation for the Triangle Count algorithm.


[[algorithms-triangle-count-syntax-stream]]
=== Stream

.Run Triangle Count in stream mode on a named graph:
[source, cypher]
----
CALL gds.triangleCount.stream(
  graphName: String,
  configuration: Map
)
YIELD
  nodeId: Integer,
  triangleCount: Integer
----

include::../common-configuration/common-parameters-named-graph.adoc[]

include::../common-configuration/common-stream-stats-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name          | Type      | Description
| nodeId        | Integer   | Node ID.
| triangleCount | Integer   | Number of triangles the node is part of. Is `-1` if the node has been excluded from computation using the `maxDegree` configuration parameter.
|===


[[algorithms-triangle-count-syntax-stats]]
=== Stats

.Run Triangle Count in stream mode on a named graph:
[source, cypher]
----
CALL gds.triangleCount.stats(
  graphName: String,
  configuration: Map
)
YIELD
  triangleCount: Integer,
  nodeCount: Integer,
  createMillis: Integer,
  computeMillis: Integer,
  configuration: Map
----

include::../common-configuration/common-parameters-named-graph.adoc[]

include::../common-configuration/common-stream-stats-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name          | Type    | Description
| triangleCount | Integer | Total number of triangles in the graph.
| nodeCount     | Integer | Number of nodes in the graph.
| createMillis  | Integer | Milliseconds for creating the graph.
| computeMillis | Integer | Milliseconds for running the algorithm.
| configuration | Map     | The configuration used for running the algorithm.
|===


[[algorithms-triangle-count-syntax-mutate]]
=== Mutate

.Run Triangle Count in mutate mode on a named graph:
[source, cypher]
----
CALL gds.triangleCount.mutate(
  graphName: String,
  configuration: Map
)
YIELD
  triangleCount: Integer,
  nodeCount: Integer,
  nodePropertiesWritten: Integer,
  createMillis: Integer,
  computeMillis: Integer,
  mutateMillis: Integer,
  configuration: Map
----

include::../common-configuration/common-parameters-named-graph.adoc[]

include::../common-configuration/common-mutate-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                  | Type    | Description
| triangleCount         | Integer | Total number of triangles in the graph.
| nodeCount             | Integer | Number of nodes in the graph.
| nodePropertiesWritten | Integer | Number of properties added to the in-memory graph.
| createMillis          | Integer | Milliseconds for creating the graph.
| computeMillis         | Integer | Milliseconds for running the algorithm.
| mutateMillis          | Integer | Milliseconds for adding properties to the in-memory graph.
| configuration         | Map     | The configuration used for running the algorithm.
|===


[[algorithms-triangle-count-syntax-write]]
=== Write

.Run Triangle Count in write mode on a named graph:
[source, cypher]
----
CALL gds.triangleCount.write(
  graphName: String,
  configuration: Map
)
YIELD
  triangleCount: Integer,
  nodeCount: Integer,
  nodePropertiesWritten: Integer,
  createMillis: Integer,
  computeMillis: Integer,
  writeMillis: Integer,
  configuration: Map
----

include::../common-configuration/common-parameters-named-graph.adoc[]

include::../common-configuration/common-mutate-configuration-named-graph.adoc[]

include::specific-configuration.adoc[]

.Results
[opts="header",cols="1,1,6"]
|===
| Name                  | Type    | Description
| triangleCount         | Integer | Total number of triangles in the graph.
| nodeCount             | Integer | Number of nodes in the graph.
| nodePropertiesWritten | Integer | Number of properties written to Neo4j.
| createMillis          | Integer | Milliseconds for creating the graph.
| computeMillis         | Integer | Milliseconds for running the algorithm.
| writeMillis           | Integer | Milliseconds for writing results back to Neo4j.
| configuration         | Map     | The configuration used for running the algorithm.
|===


[[algorithms-triangle-count-syntax-anonymous]]
=== Anonymous graphs

It is also possible to execute the algorithm on a graph that is projected in conjunction with the algorithm execution.
In this case, the graph does not have a name, and we call it anonymous.
When executing over an anonymous graph the configuration map contains graph projection configuration as well as algorithm configuration.
All execution modes support execution on anonymous graphs, although we only show syntax and mode-specific configuration for the `write` mode for brevity.
For more information on syntax variants, see <<algorithms-syntax>>.

.Run Triangle Count in write mode on an anonymous graph:
[source, cypher]
----
CALL gds.triangleCount.write(
  configuration: Map
)
YIELD
  triangleCount: Integer,
  nodeCount: Integer,
  nodePropertiesWritten: Integer,
  createMillis: Integer,
  computeMillis: Integer,
  writeMillis: Integer,
  configuration: Map
----

include::../common-configuration/common-write-configuration-anonymous-graph.adoc[]

include::specific-configuration.adoc[]

The results are the same as for running write mode with a named graph, <<algorithms-triangle-count-syntax-write, specified above>>.


[[algorithms-triangle-count-examples]]
== Examples

In this section we will show examples of executing the Triangle Count algorithm on a concrete graph.
The intention is to illustrate what the results look like and to provide a guide in how to make use of the algorithm in a real setting.
We will do this on a small social network graph of a handful nodes connected in a particular pattern.
The example graph looks like this:

[[algorithms-triangle-count-examples-graph]]
image::triangle_count.png[]

.The following Cypher statement will create the example graph in the Neo4j database:
[source, cypher, role=setup-query]
----
CREATE
  (alice:Person {name: 'Alice'}),
  (michael:Person {name: 'Michael'}),
  (karin:Person {name: 'Karin'}),
  (chris:Person {name: 'Chris'}),
  (will:Person {name: 'Will'}),
  (mark:Person {name: 'Mark'}),

  (michael)-[:KNOWS]->(karin),
  (michael)-[:KNOWS]->(chris),
  (will)-[:KNOWS]->(michael),
  (mark)-[:KNOWS]->(michael),
  (mark)-[:KNOWS]->(will),
  (alice)-[:KNOWS]->(michael),
  (will)-[:KNOWS]->(chris),
  (chris)-[:KNOWS]->(karin)
----

With the graph in Neo4j we can now project it into the graph catalog to prepare it for algorithm execution.
We do this using a native projection targeting the `Person` nodes and the `KNOWS` relationships.
For the relationships we must use the `UNDIRECTED` orientation.
This is because the Triangle Count algorithm is defined only for undirected graphs.

include::../shared/examples-named-native-note.adoc[]

.The following statement will create a graph using a native projection and store it in the graph catalog under the name 'myGraph'.
[source, cypher, role=graph-create-query]
----
CALL gds.graph.create(
  'myGraph',
  'Person',
  {
    KNOWS: {
      orientation: 'UNDIRECTED'
    }
  }
)
----

WARNING: The Triangle Count algorithm requires the graph to be created using the `UNDIRECTED` orientation for relationships.

In the following examples we will demonstrate using the Triangle Count algorithm on this graph.


[[algorithms-triangle-count-examples-memory-estimation]]
=== Memory Estimation

:mode: write
include::../shared/examples-estimate-intro.adoc[]

[role=query-example]
--
.The following will estimate the memory requirements for running the algorithm in write mode:
[source, cypher]
----
CALL gds.triangleCount.write.estimate('myGraph', { writeProperty: 'triangleCount' })
YIELD nodeCount, relationshipCount, bytesMin, bytesMax, requiredMemory
----

.Results
[opts="header"]
|===
| nodeCount | relationshipCount | bytesMin | bytesMax | requiredMemory
| 6         | 16                | 144      | 144      | "144 Bytes"
|===
--

Note that the relationship count is 16 although we only created 8 relationships in the original Cypher statement.
This is because we used the `UNDIRECTED` orientation, which will project each relationship in each direction, effectively doubling the number of relationships.


[[algorithms-triangle-count-examples-stream]]
=== Stream

:stream-details: For example, we can order the results to find the nodes with the highest triangle count.
include::../shared/examples-stream-intro.adoc[]

.The following will run the algorithm in `stream` mode:
[role=query-example]
--
[source, cypher]
----
CALL gds.triangleCount.stream('myGraph')
YIELD nodeId, triangleCount
RETURN gds.util.asNode(nodeId).name AS name, triangleCount
ORDER BY triangleCount DESC
----

.Results
[opts="header",cols="1,1"]
|===
| name      | triangleCount
| "Michael" | 3
| "Chris"   | 2
| "Will"    | 2
| "Karin"   | 1
| "Mark"    | 1
| "Alice"   | 0
|===
--

Here we find that the 'Michael' node has the most triangles.
This can be verified in the <<algorithms-triangle-count-examples-graph, example graph>>.
Since the 'Alice' node only `KNOWS` one other node, it can not be part of any triangle, and indeed the algorithm reports a count of zero.


[[algorithms-triangle-count-examples-stats]]
=== Stats

:stats-details: The summary result contains the global triangle count, which is the total number of triangles in the entire graph.
:stats-syntax: algorithms-triangle-count-syntax-stats
include::../shared/examples-stats-intro.adoc[]

.The following will run the algorithm in `stats` mode:
[role=query-example]
--
[source, cypher]
----
CALL gds.triangleCount.stats('myGraph')
YIELD globalTriangleCount, nodeCount
----

.Results
[opts="header"]
|===
| globalTriangleCount | nodeCount
| 3                   | 6
|===
--

Here we can see that the graph has six nodes with a total number of three triangles.
Comparing this to the <<algorithms-triangle-count-examples-stream, stream example>> we can see that the 'Michael' node has a triangle count equal to the global triangle count.
In other words, that node is part of all of the triangles in the graph and thus has a very central position in the graph.


[[algorithms-triangle-count-examples-mutate]]
=== Mutate

:mutate-details: For example, using the triangle count to compute the <<algorithms-local-clustering-coefficient-examples-pre-computed, local clustering coefficient>>.
include::../shared/examples-mutate-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm in `mutate` mode:
[source, cypher]
----
CALL gds.triangleCount.mutate('myGraph', {
  mutateProperty: 'triangles'
})
YIELD globalTriangleCount, nodeCount
----

.Results
[opts="header"]
|===
| globalTriangleCount | nodeCount
| 3                   | 6
|===
--

The returned result is the same as in the `stats` example.
Additionally, the graph 'myGraph' now has a node property `triangles` which stores the triangle count for each node.
To find out how to inspect the new schema of the in-memory graph, see <<catalog-graph-list>>.


[[algorithms-triangle-count-examples-write]]
=== Write

include::../shared/examples-write-intro.adoc[]

[role=query-example]
--
.The following will run the algorithm in `write` mode:
[source, cypher]
----
CALL gds.triangleCount.write('myGraph', {
  writeProperty: 'triangles'
})
YIELD globalTriangleCount, nodeCount
----

.Results
[opts="header"]
|===
| globalTriangleCount | nodeCount
| 3                   | 6
|===
--

The returned result is the same as in the `stats` example.
Additionally, each of the six nodes now has a new property `triangles` in the Neo4j database, containing the triangle count for that node.


[[algorithms-triangle-count-examples-max-degree]]
=== Maximum Degree

The Triangle Count algorithm supports a `maxDegree` configuration parameter that can be used to exclude nodes from processing if their degree is greater than the configured value.
This can be useful to speed up the computation when there are nodes with a very high degree (so-called super nodes) in the graph.
Super nodes have a great impact on the performance of the Triangle Count algorithm.
To learn about the degree distribution of your graph, see <<catalog-graph-list>>.

The nodes excluded from the computation get assigned a triangle count of `-1`.

.The following will run the algorithm in `stream` mode with the `maxDegree` parameter:
[role=query-example]
--
[source, cypher]
----
CALL gds.triangleCount.stream('myGraph', {
  maxDegree: 4
})
YIELD nodeId, triangleCount
RETURN gds.util.asNode(nodeId).name AS name, triangleCount
ORDER BY name ASC
----

.Results
[opts="header"]
|===
| name      | triangleCount
| "Alice"   | 0
| "Chris"   | 0
| "Karin"   | 0
| "Mark"    | 0
| "Michael" | -1
| "Will"    | 0
|===
--

Running the algorithm on the example graph with `maxDegree: 4` excludes the 'Michael' node from the computation, as it has a degree of 5.

As this node is part of all the triangles in the example graph excluding it results in no triangles.
