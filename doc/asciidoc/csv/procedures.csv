¦qualified name¦description¦type
¦algo.betweenness¦CALL algo.betweenness(label:String, relationship:String, {direction:'out',write:true, writeProperty:'centrality', stats:true, concurrency:4}) YIELD loadMillis, computeMillis, writeMillis, nodes, minCentrality, maxCentrality, sumCentrality - yields status of evaluation¦procedure
¦algo.betweenness.sampled.stream¦CALL algo.betweenness.sampled.stream(label:String, relationship:String, {strategy:{'random', 'degree'}, probability:double, maxDepth:int, direction:String, concurrency:int}) YIELD nodeId, centrality - yields centrality for each node¦procedure
¦algo.betweenness.sampled¦CALL algo.betweenness.sampled(label:String, relationship:String, {strategy:'random', probability:double, maxDepth:5, direction:'out',write:true, writeProperty:'centrality', stats:true, concurrency:4}) YIELD loadMillis, computeMillis, writeMillis, nodes, minCentrality, maxCentrality, sumCentrality - yields status of evaluation¦procedure
¦algo.betweenness.stream¦CALL algo.betweenness.stream(label:String, relationship:String, {direction:'out', concurrency :4})YIELD nodeId, centrality - yields centrality for each node¦procedure
¦algo.closeness¦CALL algo.closeness(label:String, relationship:String, {write:true, writeProperty:'centrality, concurrency:4'}) YIELD loadMillis, computeMillis, writeMillis, nodes] - yields evaluation details¦procedure
¦algo.closeness.stream¦CALL algo.closeness.stream(label:String, relationship:String{concurrency:4}) YIELD nodeId, centrality - yields centrality for each node¦procedure
¦algo.degree¦CALL algo.degree(label:String, relationship:String, { weightProperty: null, write: true, writeProperty:'degree', concurrency:4}) YIELD nodes, iterations, loadMillis, computeMillis, writeMillis, dampingFactor, write, writeProperty - calculates degree centrality and potentially writes back¦procedure
¦algo.degree.stream¦CALL algo.degree.stream(label:String, relationship:String, {weightProperty: null, concurrency:4}) YIELD node, score - calculates degree centrality and streams results¦procedure
¦algo.graph.info¦CALL algo.graph.info(name:String, degreeDistribution:bool | { direction:'OUT/IN/BOTH', concurrency:int }) YIELD name, type, exists, nodes, relationships¦procedure
¦algo.graph.load¦CALL algo.graph.load(name:String, label:String, relationship:String{direction:'OUT/IN/BOTH', undirected:true/false, sorted:true/false, nodeProperty:'value', nodeWeight:'weight', relationshipWeight: 'weight', graph:'heavy/huge/cypher'}) YIELD nodes, relationships, loadMillis, computeMillis, writeMillis, write, nodeProperty, nodeWeight, relationshipWeight - load named graph¦procedure
¦algo.graph.remove¦CALL algo.graph.remove(name:String)¦procedure
¦algo.labelPropagation¦CALL algo.labelPropagation(label:String, relationship:String, direction:String, {iterations:1, weightProperty:'weight', partitionProperty:'partition', write:true, concurrency:4}) YIELD nodes, iterations, didConverge, loadMillis, computeMillis, writeMillis, write, weightProperty, partitionProperty - simple label propagation kernel¦procedure
¦algo.labelPropagation.stream¦CALL algo.labelPropagation.stream(label:String, relationship:String, config:Map<String, Object>) YIELD nodeId, label¦procedure
¦algo.louvain¦CALL algo.louvain(label:String, relationship:String, {weightProperty:'weight', defaultValue:1.0, write: true, writeProperty:'community', concurrency:4, communityProperty:'propertyOfPredefinedCommunity', innerIterations:10, communitySelection:'classic'}) YIELD nodes, communityCount, iterations, loadMillis, computeMillis, writeMillis¦procedure
¦algo.louvain.stream¦CALL algo.louvain.stream(label:String, relationship:String, {weightProperty:'propertyName', defaultValue:1.0, concurrency:4, communityProperty:'propertyOfPredefinedCommunity', innerIterations:10, communitySelection:'classic') YIELD nodeId, community - yields a setId to each node id¦procedure
¦algo.pageRank¦CALL algo.pageRank(label:String, relationship:String, {iterations:5, dampingFactor:0.85, weightProperty: null, write: true, writeProperty:'pagerank', concurrency:4}) YIELD nodes, iterations, loadMillis, computeMillis, writeMillis, dampingFactor, write, writeProperty - calculates page rank and potentially writes back¦procedure
¦algo.pageRank.stream¦CALL algo.pageRank.stream(label:String, relationship:String, {iterations:20, dampingFactor:0.85, weightProperty: null, concurrency:4}) YIELD node, score - calculates page rank and streams results¦procedure
¦algo.unionfind¦CALL algo.unionFind(label = :: STRING?, relationship = :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)¦procedure
