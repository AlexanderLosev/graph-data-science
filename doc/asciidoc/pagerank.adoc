[[algorithms-pagerank]]
= The PageRank algorithm

[abstract]
--
This section describes the PageRank algorithm in the Neo4j Graph Algorithms library.
--

// tag::introduction[]
PageRank is an algorithm that measures the *transitive* influence or connectivity of nodes.

It can be computed by either iteratively distributing one node's rank (originally based on degree) over its neighbours or by randomly traversing the graph and counting the frequency of hitting each node during these walks.

// TODO: Eigenvector is labs, so "a variant" might be misleading?
PageRank is a variant of <<labs-algorithms-eigenvector, Eigenvector Centrality>>.
// end::introduction[]

This section includes:

* <<algorithms-pagerank-intro, Introduction>>
* <<algorithms-pagerank-syntax, Syntax>>
* <<algorithms-pagerank-examples, Examples>>
** <<algorithms-pagerank-examples-unweighted, Unweighted>>
** <<algorithms-pagerank-examples-weighted, Weighted>>
*** <<algorithms-pagerank-examples-personalized, Personalized>>

[[algorithms-pagerank-intro]]
== Introduction

The PageRank algorithm measures the importance of each page (equal to a node) within the graph, based on the number and quality of incoming relationships.
The underlying assumption is that pages of importance are more likely to receive a higher volume of links from other pages.

// tag::formula[]
PageRank is defined in the original Google paper as follows:

----
PR(A) = (1-d) + d (PR(T1)/C(T1) + ... + PR(Tn)/C(Tn))
----

where,

* we assume that a page `A` has pages `T1` to `Tn` which point to it (i.e., are citations).
* `d` is a damping factor which can be set between 0 and 1.
  It is usually set to 0.85.
* `C(A)` is defined as the number of links going out of page `A`.
// end::formula[]


There are some things to be aware of when using the PageRank algorithm:

* If there are no links from within a group of pages to outside of the group, then the group is considered a spider trap.
* Rank sink can occur when a network of pages form an infinite cycle.
* Dead-ends occur when pages have no out-links.
If a page contains a link to another page which has no out-links, the link would be known as a dangling link.


For more information on this algorithm, see:

* http://infolab.stanford.edu/~backrub/google.html[The original google paper^]
// according to java doc implantation based on
* http://delab.csd.auth.gr/~dimitris/courses/ir_spring06/page_rank_computing/01531136.pdf[An Efficient Partition-Based Parallel PageRank Algorithm^]
* https://arxiv.org/pdf/1407.5107.pdf[PageRank beyond the web^] for more use cases


[NOTE]
====
Running this algorithm requires sufficient memory availability.
Before running this algorithm, we recommend that you read <<memory-requirements>>.
====

[[algorithms-pagerank-syntax]]
== Syntax

.The following will run the algorithm and write back results:
[source, cypher]
----
CALL algo.pageRank(label:String, relationship:String,
    {direction: 'OUTGOING', iterations: 20, tolerance: 0.0000001, dampingFactor: 0.85, write: true, writeProperty: 'pagerank', concurrency: 4})
YIELD nodes, iterations, loadMillis, computeMillis, writeMillis, dampingFactor, write, writeProperty
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name               | Type    | Default        | Optional | Description
| node label         | string  | null           | yes      | The label to load from the graph. If null, load all nodes.
| relationship type  | string  | null           | yes      | The relationship type to load from the graph. If null, load all relationships.
| config             | map     | n/a            | yes      | Additional configuration.
|===

.Configuration
[opts="header",cols="1,1,1,1,4"]
|===
| direction         | string  | 'OUTGOING'             | yes | The relationship direction to use in the algorithm.
| iterations        | int     | 20                     | yes | How many iterations of PageRank to run.
| tolerance         | float   | 0.0000001              | yes | Minimum change in scores between iterations. If the score changes less than the tolerance value the result is considered stable and the algorithm returns.
| concurrency       | int     | available CPUs         | yes | The number of concurrent threads used for running the algorithm. Also provides the default value for 'readConcurrency' and 'writeConcurrency'.
| readConcurrency   | int     | value of 'concurrency' | yes | The number of concurrent threads used for reading the graph.
| writeConcurrency  | int     | value of 'concurrency' | yes | The number of concurrent threads used for writing the result.
| dampingFactor     | float   | 0.85                   | yes | The damping factor of the PageRank calculation.
| weightProperty    | string  | null                   | yes | The property name that contains weight. If null, treats the graph as unweighted. Must be numeric.
| defaultValue      | float   | 0.0                    | yes | The default value of the weight in case it is missing or invalid.
| write             | boolean | true                   | yes | Specify if the result should be written back as a node property.
| graph             | string  | 'huge'                 | yes | Use 'huge' when describing the subset of the graph with label and relationship-type parameter. Use 'cypher' for describing the subset with cypher node statement and relationship statement.
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name          | Type    | Description
| nodes         | int     | The number of nodes considered.
| iterations    | int     | The number of iterations run.
| dampingFactor | float   | The damping factor used.
| writeProperty | string  | The property name written back to.
| write         | boolean | Specifies if the result was written back as node property.
| loadMillis    | int     | Milliseconds for loading data.
| computeMillis | int     | Milliseconds for running the algorithm.
| writeMillis   | int     | Milliseconds for writing result data back.
|===

.The following will run the algorithm and stream results:
[source, cypher]
----
CALL algo.pageRank.stream(label:String, relationship:String,
    {direction:'OUTGOING', iterations:20, dampingFactor:0.85, concurrency:4})
YIELD node, score
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name               | Type    | Default        | Optional | Description
| node label         | string  | null           | yes      | The label to load from the graph. If null, load all nodes.
| relationship type  | string  | null           | yes      | The relationship type to load from the graph. If null, load all relationships.
| config             | map     | n/a            | yes      | Additional configuration.
|===

.Configuration
[opts="header",cols="1,1,1,1,4"]
|===
| direction        | string | 'OUTGOING'             | yes | The relationship direction to use in the algorithm.
| iterations       | int    | 20                     | yes | Specify how many iterations of PageRank to run.
| tolerance        | float  | 0.0000001              | yes | Minimum change in scores between iterations. If the score changes less than the tolerance value the result is considered stable and the algorithm returns.
| concurrency      | int    | available CPUs         | yes | The number of concurrent threads used for running the algorithm. Also provides the default value for 'readConcurrency'.
| readConcurrency  | int    | value of 'concurrency' | yes | The number of concurrent threads used for reading the graph.
| writeConcurrency | int    | value of 'concurrency' | yes | The number of concurrent threads used for writing the result.
| dampingFactor    | float  | 0.85                   | yes | The damping factor of the PageRank calculation.
| weightProperty   | string | null                   | yes | The property name that contains weight. If null, treats the graph as unweighted. Must be numeric.
| defaultValue     | float  | 0.0                    | yes | The default value of the weight in case it is missing or invalid.
| graph            | string | 'huge'                 | yes | Use 'huge' when describing the subset of the graph with label and relationship-type parameter. Use 'cypher' for describing the subset with cypher node statement and relationship statement.
|===

.Results
[opts="header"]
|===
| Name  | Type  | Description
| nodeId  | long  | Node ID
| score | float | PageRank weight
|===



// TODO: also constraints?
// TODO: Call out to graph loading?

[[algorithms-pagerank-examples]]
== Examples

Consider the graph created by the following Cypher statement:

[source, cypher]
----
MERGE (home:Page {name:'Home'})
MERGE (about:Page {name:'About'})
MERGE (product:Page {name:'Product'})
MERGE (links:Page {name:'Links'})
MERGE (a:Page {name:'Site A'})
MERGE (b:Page {name:'Site B'})
MERGE (c:Page {name:'Site C'})
MERGE (d:Page {name:'Site D'})

MERGE (home)-[:LINKS]->(about)
MERGE (about)-[:LINKS]->(home)
MERGE (product)-[:LINKS]->(home)
MERGE (home)-[:LINKS]->(product)
MERGE (links)-[:LINKS]->(home)
MERGE (home)-[:LINKS]->(links)
MERGE (links)-[:LINKS]->(a)
MERGE (a)-[:LINKS]->(home)
MERGE (links)-[:LINKS]->(b)
MERGE (b)-[:LINKS]->(home)
MERGE (links)-[:LINKS]->(c)
MERGE (c)-[:LINKS]->(home)
MERGE (links)-[:LINKS]->(d)
MERGE (d)-[:LINKS]->(home)
----

[[algorithms-pagerank-examples-unweighted]]
=== Unweighted

.The following will run the algorithm and stream results:
[source, cypher]
----
CALL algo.pageRank.stream('Page', 'LINKS', {
  iterations:20,
  dampingFactor:0.85
})
YIELD nodeId, score
RETURN algo.asNode(nodeId).name AS Name, score AS PageRank
ORDER BY score DESC
----

.Results
[opts="header",cols="1,1"]
|===
| Name    | PageRank
| Home    | 3.232
| Product | 1.059
| Links   | 1.059
| About   | 1.059
| Site A  | 0.328
| Site B  | 0.328
| Site C  | 0.328
| Site D  | 0.328
|===

To instead write the page-rank score to a node property in the Neo4j graph, use this query:

.The following will run the algorithm and write back results:
[source, cypher]
----
CALL algo.pageRank('Page', 'LINKS', {
  iterations:20,
  dampingFactor:0.85,
  write: true,
  writeProperty:"pagerank"
})
YIELD nodes AS Nodes, iterations AS Iterations, dampingFactor AS DampingFactor, writeProperty AS PropertyName
----

.Results
[opts="header",cols="1m,1m,1m,1m"]
|===
| Nodes | Iterations | DampingFactor | PropertyName
| 8     | 20         | 0.85          | "pagerank"
|===

[[algorithms-pagerank-examples-weighted]]
=== Weighted

.The following will run the algorithm and stream results:
[source, cypher]
----
CALL algo.pageRank.stream('Page', 'LINKS', {
  iterations:20,
  dampingFactor:0.85,
  weightProperty:'weight',
  write: true,
  writeProperty:'pagerank'
})
YIELD nodeId, score
RETURN algo.asNode(nodeId).name AS Name, score AS PageRank
ORDER BY score DESC
----

.Results
[opts="header",cols="1,1"]
|===
| Name    | PageRank
| Home    | 3.550
| Product | 1.954
| Links   | 0.751
| About   | 0.751
| Site A  | 0.182
| Site B  | 0.182
| Site C  | 0.182
| Site D  | 0.182
|===

To instead write the page-rank score to a node property in the Neo4j graph, use this query:

.The following will run the algorithm and write back results:
[source, cypher]
----
CALL algo.pageRank('Page', 'LINKS', {
  iterations:20,
  dampingFactor:0.85,
  weightProperty:'weight',
  write: true,
  writeProperty:'pagerank'
})
YIELD nodes AS Nodes, iterations AS Iterations, dampingFactor AS DampingFactor, writeProperty AS PropertyName
----

.Results
[opts="header",cols="1m,1m,1m,1m"]
|===
| Nodes | Iterations | DampingFactor | PropertyName
| 8     | 20         | 0.85          | "pagerank"
|===


[[algorithms-pagerank-examples-personalized]]
==== Personalized

Personalized PageRank is a variation of PageRank which is biased towards a set of `sourceNodes`.
This variant of PageRank is often used as part of https://www.r-bloggers.com/from-random-walks-to-personalized-pagerank/[recommender systems^].

The following examples show how to run PageRank centered around 'Site A'.


.The following will run the algorithm and stream results:
[source, cypher]
----
MATCH (siteA:Page {name: "Site A"})
CALL algo.pageRank.stream('Page', 'LINKS', {
  iterations:20,
  dampingFactor:0.85,
  sourceNodes: [siteA]
})
YIELD nodeId, score
RETURN algo.asNode(nodeId).name AS Name, score AS PageRank
ORDER BY score DESC
----

.Results
[opts="header",cols="1,1"]
|===
| Name    | PageRank
| Home    | 0.402
| Site A  | 0.169
| About   | 0.113
| Product | 0.113
| Links   | 0.113
| Site B  | 0.019
| Site C  | 0.019
| Site D  | 0.019
|===


.The following will run the algorithm and write back results:
[source, cypher]
----
CALL algo.pageRank('Page', 'LINKS', {
  iterations:20,
  dampingFactor:0.85,
  write: true,
  writeProperty:"pagerank"
})
YIELD nodes AS Nodes, iterations AS Iterations, dampingFactor AS DampingFactor, writeProperty AS PropertyName
----

.Results
[opts="header",cols="1m,1m,1m,1m"]
|===
| Nodes | Iterations | DampingFactor | PropertyName
| 8     | 20         | 0.85          | "pagerank"
|===