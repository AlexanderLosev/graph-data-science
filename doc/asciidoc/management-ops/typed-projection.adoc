[[typed-projection]]
// tag::header[]
= Typed projection
// end::header[]

ifdef::env-docs[]
[abstract]
--
This chapter explains node-label and relationship-type projection in the Neo4j Graph Data Science library.
--
endif::env-docs[]

We can project the subgraph we want to run the algorithm on by using the label parameter to describe nodes, and relationship type to describe relationships.

The general call syntax is:

.The following will run the algorithm for the label `NodeLabel` and relationship type `RelationshipType`
[source,cypher]
----
CALL algo.<name>('NodeLabel', "RelationshipType", {config})
----

For example, running the Page Rank algorithm on DBpedia, which contains 11 million nodes and 116 million relationships:

.The following will run the write version of the algorithm, storing results in the `pagerank` property:
[source,cypher]
----
CALL algo.pageRank('Page','Link',{iterations:5, dampingFactor:0.85, write: true, writeProperty:'pagerank'});
----

.The following will run the streaming version of the algorithm:
[source,cypher]
----
CALL algo.pageRank.stream('Page','Link',{iterations:5, dampingFactor:0.85})
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).title, score
ORDER BY score DESC LIMIT 10;
----

If we want to project a subgraph that includes all nodes and relationships in the underlying Neo4j graph, we can achieve this by passing `null` values for the label and relationship type:

.The following will run the algorithm over all nodes and relationships:
[source,cypher]
----
CALL algo.<name>(null, null)
----


[[huge-projection]]
== Huge graph projection

The default label and relationship type projection has a limitation of 2 billion nodes and 2 billion relationships, so if our project graph is bigger than this we need to use a huge graph projection.
This can be enabled by setting `graph:'huge'` in the config.

The general call syntax is:

[source,cypher]
----
CALL algo.<name>('NodeLabel', "RelationshipType", {graph: "huge"})
----

For example, running the Page Rank algorithm on DBpedia:

.The following will run the write version of the algorithm, storing results in the `pagerank` property:
[source,cypher]
----
CALL algo.pageRank('Page','Link',{iterations:5, dampingFactor:0.85, writeProperty:'pagerank',graph:'huge'});
----

If we want to project a subgraph that includes all nodes and relationships in the underlying Neo4j graph, we can achieve this by passing `null` values for the label and relationship type:

.The following will run the algorithm over all nodes and relationships:
[source,cypher]
----
CALL algo.<name>(null, null, {graph: 'huge'})
----

// == Loading multiple relationship types and node labels
//
// Using the `algo.graph.load` procedure it is possible to specify multiple relationship types and node labels.
// The loaded graph will retain the relationship type information.
// A graph loaded with multiple relationship types supports filtering subgraphs based on these types.
// Node label information is not retained in the loaded graph.
//
// Graphs loaded with an empty relationship projection, or a Cypher relationship projection query, do not retain information about relationship types.
//
// .The following example will create the graph `my-graph` with relationships that have the type `REL_TYPE1`, `REL_TYPE2` or `REL_TYPE3`:
// [source, cypher]
// ----
// CALL algo.graph.load('my-graph', null, 'REL_TYPE1 | REL_TYPE2 | REL_TYPE3', {direction: 'OUTGOING', concurrency: 8 })
// ----
//
// Having loaded the graph with multiple relationship types we can run an algorithm on a filtered subgraph based on these types.
// To run an algorithm over a subset of the graph we specify one or more of the loaded relationship types in the `relationship` parameter for the algorithm.
// If the `relationship` parameter is empty, the whole graph is used.
//
// .The following example will run Page Rank only on relationships of type `REL_TYPE1` or `REL_TYPE2`:
// [source,cypher]
// ----
// CALL algo.pageRank(null, 'REL_TYPE1 | REL_TYPE2', {graph: 'my-graph'})
// ----
//
// The same syntax used to load multiple relationship types can also be used to load multiple labels.
//
// .The following example will load a graph `my-graph` with nodes that have either the `Person` or `Instrument` label:
// [source, cypher]
// ----
// CALL algo.graph.load('my-graph', 'Person | Instrument', null, {direction: 'OUTGOING', concurrency: 8 })
// ----
//
// Unlike multiple relationship types, the node label information is not retained in the loaded graph.
//
//
// [[deduplication-of-parallel-relationships]]
// == Deduplication of parallel relationships
//
// Named graphs offer different ways of handling multiple - so called "parallel" - relationships between a given pair of nodes.
//
//
// === Node-label and relationship-type projection
//
// By default, the Huge graph assumes that the relationship projection only contains one relationship between a pair of nodes and will simply ignore all other relationships (see `skip` below).
// In order to control the deduplication behavior we can pass the `duplicateRelationships` key in the config to decide what should happen with duplicates.
//
// `duplicateRelationships` supports the following options:
//
// * `none` - keeps all relationships between a given pair of nodes / no deduplication.
// * `skip` - keeps the first encountered relationship (and associated weight).
// * `sum` - sums the associated weights of all encountered relationships.
// * `min` - keeps the minimum weight of all encountered relationships.
// * `max` - keeps the maximum weight of all encountered relationships.
//
// Note that setting an explict deduplication strategy, other then `none` or `skip` will increase the relationship loading time.
//
// .The following query loads a graph of roads between locations keeping all the `ROAD` relationships between two `Loc` nodes.
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipWeight: 'cost',
//   duplicateRelationships: 'none'})
// ----
//
// .The following query loads a graph of roads between locations keeping only those `ROAD` relationships with the minimal cost.
// [source,cypher]
// ----
// CALL algo.graph.load('cheapestRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipWeight: 'cost',
//   duplicateRelationships: 'sum'})
// ----
// == Loading multiple node properties
//
// It is often useful to load an in-memory graph with more than one node property.
// A typical scenario is running different weighted algorithms on the same graph, but with different node properties as weight.
//
// For the `load.graph` procedure, loading multiple node properties can be configured via the `nodeProperties` parameter.
// The parameter is configured using a map in which each key refers to a user-defined property key.
// Any algorithm that supports node properties, for example for node weights or seed values, can refer to these user-defined property keys.
//
// The value under each property key is a configuration, that is applied when loading node properties.
// In the configuration we specify the Neo4j node property to load.
//
// For the following example, let's assume that each `City` node stores two properties: the `population` of the city and an optional `stateId` that identifies the state in which the city is located.
//
// .The following query loads all cities, including the two properties, since not all cities have a `stateId`, we set the `defaultValue` to `0`
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: {
//     population: {
//         property: 'population'
//     },
//     seedValue: {
//         property: 'stateId',
//         defaultValue: 0
//     }
//   }
// })
// ----
//
// We can refer to the loaded properties in each algorithm that supports reading node properties.
// For a path search algorithm, one could use the `population` as node weight whereas a clustering algorithm could use the `stateId` as seed value.
//
// We can also use the <<cypher-projection, Cypher projection>> to load multiple node properties.
// Here, the specified Neo4j node property must appear in the `RETURN` clause of the node query.
// If a property is not present on a node in Neo4j, the given default value is used instead.
//
// .The following query also loads all cities including their `population` and `stateId` properties
// [source,cypher]
// ----
// CALL gds.graph.create.cypher('cities',
//   'MATCH (c:City) RETURN id(c) AS id, c.population AS population, c.stateId AS stateId',
//   'MATCH (a:City)-->(b:City) RETURN id(a) AS sourceId, id(b) AS targetId',
//   {
//     nodeProperties: {
//       population: {
//           property: 'population'
//       },
//       seedValue: {
//           property: 'stateId',
//           defaultValue: 0
//       }
//   }
// })
// ----
//
// .If we just want to refer to the Neo4j node property key, we can use the following shorthand syntax:
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: {
//     population: 'population',
//     seedValue: 'stateId'
//   }
// })
// ----
//
// .We can also use the `nodeProperties` parameter to load a single node property:
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: 'population'
// })
// ----
//
//
// == Loading multiple relationship properties
//
// Similar to node properties, the `load.graph` procedure also supports loading multiple relationship properties.
// Those can be configured via the `relationshipProperties` parameter.
//
// As for nodes, the parameter is configured using a map in which each key refers to a user-defined property key.
// In addition to the Neo4j relationship property and an optional default value, we can define an aggregation function to set the deduplication behavior and a default property value which is used for absent property values (see <<deduplication-of-parallel-relationships>>).
//
// For the following example, let's assume that each `ROAD` relationship stores two properties: the `cost` (distance) and the road `quality` (between 1 and 10).
//
// .The following query loads all roads, deduplicates parallel relationships and aggregates them by their distance and also by their quality.
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipProperties: {
//     minDistance: {
//         property: 'cost',
//         aggregation: 'MIN',
//         defaultValue: 1.0
//     },
//     maxQuality: {
//         property: 'quality',
//         aggregation: 'MAX',
//         defaultValue: 5.0
//     }
//   }
// })
// ----
//
// When executed, our `allRoads` in-memory graph stores two relationship properties: `minDistance` and `maxQuality`.
// We can access the loaded properties by specifying them in an algorithm configuration.
// Let us use `gds.alpha.shortestPath` again as an example weighted algorithm.
//
// .We first compute the shortest path using the `minDistance` property as weight to compute the path with shortest distance:
// [source,cypher]
// ----
// MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
// CALL gds.alpha.shortestPath.write(
//   'allRoads',
//   {
//       startNode: start,
//       endNode: end,
//       weightProperty: 'minDistance'
//   }
// ) YIELD writeMillis, loadMillis, nodeCount, totalCost
// RETURN writeMillis, loadMillis, nodeCount, totalCost
// ----
//
// .We use the same graph, but the `maxQuality` property if we are interested in the path with the best quality:
// [source,cypher]
// ----
// MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
// CALL gds.alpha.shortestPath.write(
//   'allRoads',
//   {
//       startNode: start,
//       endNode: end,
//       weightProperty: 'maxQuality'
//   }
// ) YIELD writeMillis, loadMillis, nodeCount, totalCost
// RETURN writeMillis, loadMillis, nodeCount, totalCost
// ----
//
// With the short-hand syntax for specifying property mappings we can skip the `aggregation` and `defaultWeight` parameters.
// If those are omitted, the procedure uses `SKIP` as default aggregation function and `Double.NaN` as default property value.
//
// .The following query loads the graph and allows us to refer to the `cost` property via `distance`:
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipProperties: { distance: 'cost' }
// })
// ----
//
// Note that in this particular shortest path example, using the default property value is not recommended.
//
// [NOTE]
// ====
// Loading multiple relationship properties is currently only supported for node-label and relationship-type projections.
// ====
//
// [CAUTION]
// ====
// As with relationship types, loading a lot of multiple relationship properties can have a negative impact on performace, both during load and execution time.
// It is best to only load as few properties as needed.
// ====