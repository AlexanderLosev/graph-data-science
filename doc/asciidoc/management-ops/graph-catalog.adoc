[[graph-catalog-ops]]
= Graph Catalog

Graph algorithms run on a graph data model which is a _projection_ of the Neo4j property graph data model.
A graph projection can be seen as a view over the stored graph, containing only analytical relevant, potentially aggregated, topological and property information.
Graph projections are stored entirely in-memory using compressed data structures optimized for topology and property lookup operations.

The graph catalog is a concept within the GDS library that allows managing multiple graph projections by name.
Using that name, a created graph can be used many times in the analytical workflow.
Named graphs can be created using either a <<native-projection, Native projection>> or a <<cypher-projection, Cypher projection>>.
After usage, named graphs can be removed from the catalog to free up main memory.

Graphs can also be created when running an algorithm without placing them in the catalog.
We refer to such graphs as <<anonymous-graph, Anonymous graphs>>.

[NOTE]
====
The graph catalog exists as long as the Neo4j instance is running.
When Neo4j is restarted, graphs stored in the catalog are lost and need to be re-created.
====

This chapter explains the available graph catalog operations.

[[table-proc]]
[opts=header,cols="1m,1"]
|===
| Name                                                                     | Description
| <<catalog-graph-create, gds.graph.create>>                               | Creates a graph in the catalog using a <<native-projection, Native projection>>.
| <<catalog-graph-create, gds.graph.create.cypher>>                        | Creates a graph in the catalog using a <<cypher-projection, Cypher projection>>.
| <<catalog-graph-list, gds.graph.list>>                                   | Prints information about graphs that are currently stored in the catalog.
| <<catalog-graph-exists, gds.graph.exists>>                               | Checks if a named graph is stored in the catalog.
| <<catalog-graph-remove-node-properties, gds.graph.removeNodeProperties>> | Removes node properties from a named graph.
| <<catalog-graph-delete-rel-type, gds.graph.deleteRelationships>>         | Deletes relationships of a given relationship type from a named graph.
| <<catalog-graph-drop, gds.graph.drop>>                                   | Drops a named graph from the catalog.
| <<catalog-graph-write-node-properties, gds.graph.writeNodeProperties>>   | Writes node properties stored in a named graph to Neo4j.
| <<catalog-graph-write-relationship, gds.graph.writeRelationship>>        | Writes relationships stored in a named graph to Neo4j.
| <<catalog-graph-export, gds.alpha.graph.export>>                         | Exports a named graph into a new offline Neo4j database.
|===

[NOTE]
====
Creating, using, listing, and dropping named graphs are management operations bound to a Neo4j user.
Graphs created by a different Neo4j user are not accessible at any time.
====


[[catalog-graph-create]]
== Creating graphs in the catalog

A projected graph can be stored in the catalog under a user-defined name.
Using that name, the graph can be referred to by any algorithm in the library.
This allows multiple algorithms to use the same graph without having to re-create it on each algorithm run.

There are two variants of projecting a graph from the Neo4j database into main memory:

* <<native-projection, Native projection>>
** Provides the best performance by reading from the Neo4j store files.
   Recommended to be used during both the development and the production phase.
* <<cypher-projection, Cypher projection>>
** The more flexible, expressive approach with lesser focus on performance.
   Recommended to be primarily used during the development phase.

[NOTE]
====
There is also a way to generate a random graph, see <<graph-generation, Graph Generation>> documentation for more details.
====

In this section, we will give brief examples on how to create a graph using either variant.
For detailed information about the configuration of each variant, we refer to the dedicated sections.

In the following two examples we show how to create a graph called `my-native-graph` that contains `Person` nodes and `LIKES` relationships.

.Create a graph using a native projection:
[source,cypher, role=noplay]
----
CALL gds.graph.create(
    'my-native-graph',
    'Person',
    'LIKES'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

We can also use Cypher to select the nodes and relationships to be projected into the in-memory graph.

.Create a graph using a Cypher projection:
[source,cypher, role=noplay]
----
CALL gds.graph.create.cypher(
    'my-cypher-graph',
    'MATCH (n:Person) RETURN id(n) AS id',
    'MATCH (a:Person)-[:LIKES]->(b:Person) RETURN id(a) AS source, id(b) AS target'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

After creating the graphs in the catalog, we can refer to them in algorithms by using their name.

.Run Page Rank on one of our created graphs:
[source,cypher, role=noplay]
----
CALL gds.pageRank.stream('my-native-graph') YIELD nodeId, score;
----


[[catalog-graph-list]]
== Listing graphs in the catalog

Information about graphs in the catalog can be listed using the `gds.graph.list()` procedure.
The procedure takes an optional parameter `graphName`:

* If a graph name is given, only information for that graph will be listed.
* If no graph name is given, information about all graphs will be listed.
* If a graph name is given but not found in the catalog, an error will be raised.

.List information about graphs in the catalog:
[source,cypher, role=noplay]
----
CALL gds.graph.list(
  graphName: String?
) YIELD
  graphName,
  nodeProjection,
  relationshipProjection,
  nodeQuery,
  relationshipQuery,
  nodeCount,
  relationshipCount,
  degreeDistribution,
  creationTime,
  modificationTime;
----

.Results
[opts="header",cols="1m,1,6"]
|===
| Name                   | Type     | Description
| graphName              | String   | Name of the graph.
| nodeProjection         | Map      | Node projection used to create the graph. If a Cypher projection was used, this will be an automatically generated node projection.
| relationshipProjection | Map      | Relationship projection used to create the graph. If a Cypher projection was used, this will be an automatically generated relationship projection.
| nodeQuery              | String   | Node query used to create the graph. If a native projection was used, this will be `null`.
| relationshipQuery      | String   | Relationship query used to create the graph. If a native projection was used, this will be `null`.
| nodeCount              | Integer  | Number of nodes in the graph.
| relationshipCount      | Integer  | Number of relationships in the graph.
| degreeDistribution     | Map      | Histogram of degrees in the graph.
| creationTime           | Datetime | Time when the graph was created.
| modificationTime       | Datetime | Time when the graph was last modified.
|===

The information contains basic statistics about the graph, e.g., the node and relationship count.
The result field `creationTime` indicates when the graph was created in memory.
The result field `modificationTime` indicates when the graph was updated by an algorithm running in `mutate` mode.

The `degreeDistribution` field can be fairly time-consuming to compute for larger graphs.
To avoid computing the degree distribution, specify a `YIELD` clause that omits it.
Note that not specifying a `YIELD` clause is the same as requesting all possible return fields to be returned.


=== Examples

.List basic information about all graphs in the catalog:
[source,cypher, role=noplay]
----
CALL gds.graph.list()
YIELD graphName, nodeCount, relationshipCount;
----

.List extended information about a specific named graph in the catalog:
[source,cypher, role=noplay]
----
CALL gds.graph.list('my-cypher-graph')
YIELD graphName, nodeQuery, relationshipQuery, nodeCount, relationshipCount, creationTime, modificationTime;
----

.List information about the degree distribution of a specific graph:
[source,cypher, role=noplay]
----
CALL gds.graph.list('my-cypher-graph')
YIELD graphName, degreeDistribution;
----


[[catalog-graph-exists]]
== Check if a graph exists in the catalog

We can check if a graph is stored in the catalog by looking up its name.

.Check if a graph exists in the catalog:
[source,cypher, role=noplay]
----
CALL gds.graph.exists('my-store-graph') YIELD exists;
----


[[catalog-graph-remove-node-properties]]
== Removing node properties from a named graph

We can remove node properties from a named graph in the catalog.
This is useful to free up main memory or to remove accidentally created node properties.

.Remove multiple node properties from a named graph:
[source,cypher, role=noplay]
----
CALL gds.graph.removeNodeProperties('my-graph', ['pageRank', 'communityId'])
----


[[catalog-graph-delete-rel-type]]
== Deleting relationship types from a named graph

We can delete all relationships of a given type from a named graph in the catalog.
This is useful to free up main memory or to remove accidentally created relationship types.

.Delete all relationships of type T from a named graph:
[source,cypher, role=noplay]
----
CALL gds.graph.deleteRelationships('my-graph', 'T')
YIELD graphName, relationshipType, deletedRelationships, deletedProperties
----


[[catalog-graph-drop]]
== Removing graphs from the catalog

Once we have finished using the named graph we can remove it from the catalog to free up memory.

.Remove a graph from the catalog:
[source,cypher, role=noplay]
----
CALL gds.graph.drop('my-store-graph') YIELD graphName;
----


[[catalog-graph-write-node-properties]]
== Write node properties to Neo4j

We can write node properties stored in a named in-memory graph back to Neo4j.
This is useful if we ran multiple algorithms in `mutate` mode and want to write back some or all of the results.
This is similar to what the `write` execution mode does, but allows more fine-grained control over the operations.

The properties to write are typically the `writeProperty` values that were used when running algorithms.
Properties that were added to the created graph at creation time will often already be present in the Neo4j database.

.Write multiple node properties to Neo4j:
[source,cypher, role=noplay]
----
CALL gds.graph.writeNodeProperties('my-graph', ['componentId', 'pageRank', 'communityId'])
----


[[catalog-graph-write-relationship]]
== Write relationships to Neo4j

We can write relationships stored in a named in-memory graph back to Neo4j.
This can be used to write algorithm results (for example from <<algorithms-node-similarity, Node Similarity>>) or relationships that have been aggregated during graph creation.

The relationships to write are specified by a relationship type.
This can either be an element identifier used in a relationship projection during graph construction or the `writeRelationshipType` used in algorithms that create relationships.

.Write relationships to Neo4j:
[source,cypher, role=noplay]
----
CALL gds.graph.writeRelationship('my-graph', 'SIMILAR_TO')
----

By default, no relationship properties will be written.
To write relationship properties, these have to be explicitly specified.

.Write relationships and their properties to Neo4j:
[source,cypher, role=noplay]
----
CALL gds.graph.writeRelationship('my-graph', 'SIMILAR_TO', 'similarityScore')
----


[[catalog-graph-export]]
[.alpha]
== Create Neo4j databases from named graphs

[.tier-note]
*This procedure is in the alpha tier and could be changed or removed in a future release.*

We can create new Neo4j databases from named in-memory graphs stored in the graph catalog.
All nodes, relationships and properties present in an in-memory graph are written to a new Neo4j database.
This includes data that has been projected in `gds.graph.create` and data that has been added by running algorithms in `mutate` mode.
After exporting the graph, the new database can be be used in a Neo4j installation by setting link:https://neo4j.com/docs/operations-manual/3.5/reference/configuration-settings/#config_dbms.active_database[`dbms.active_database`].

The feature is useful in the following, exemplary scenarios:

* Avoid heavy write load on the operational system by exporting the data instead of writing back.
* Create an analytical view of the operational system that can be used as a basis for running algorithms.
* Produce snapshots of analytical results and persistent them for archiving and inspection.
* Share analytical results within the organization.

.Export a named graph to a specific store directory:
[source,cypher, role=noplay]
----
CALL gds.alpha.graph.export('my-graph', {
   storeDir: '/path/to/database',
   dbName: 'my-graph-db'
})
----

Note that `storeDir` must exist in the local file system.
The procedure yields information about the number of nodes, relationships and properties written.
Optional parameters are `writeConcurrency`, `enableDebugLog` and `batchSize`.
