[[native-projection]]
// tag::header[]
= Native projection
// end::header[]

[abstract]
--
This chapter explains native projections in the Neo4j Graph Data Science library.
--

A native projection allows us to project a graph from Neo4j into an in-memory graph.
The projected graph can be described in terms of node labels, relationship types and properties.
Node labels and node properties are projected using <<native-projection-syntax-node-projections>>.
Relationship types and relationship properties are projected using <<native-projection-syntax-relationship-projections>>.

The main benefit of native projections is the performance when creating a graph projection.
In contrast, a <<cypher-projection>> is more flexible from the declaration point of view, but less performant.
In most cases it is possible to structure your Neo4j databases in a way that native projections can be used.

This section includes:

* <<native-projection-syntax>>
* <<native-projection-syntax-node-projections>>
* <<native-projection-syntax-relationship-projections>>


[[native-projection-syntax]]
== Syntax

A native projection takes three mandatory arguments: `graphName`, `nodeProjection`, `relationshipProjection`.
In addition, the optional `configuration` parameter allows us to further configure graph creation.

[source,cypher]
----
CALL gds.graph.create(
    graphName: string,
    nodeProjection: string or map,
    relationshipProjection: string or map,
    configuration: map
)
----

.Parameters
[opts="header",cols="1,1,1"]
|===
| Name                   | Optional | Description
| graphName              | no       | The name under which the graph is stored in the catalog.
| nodeProjection         | no       | One or more <<native-projection-syntax-node-projections, node projections>>.
| relationshipProjection | no       | One or more <<native-projection-syntax-relationship-projections, relationship projections>>.
| configuration          | yes      | Additional parameters to configure the Native projection.
|===

.Configuration
[opts="header",cols="1,1,1,4"]
|===
| Name                   | Type    | Default        | Description
| concurrency            | int     | available CPUs | The number of concurrent threads used for creating the graph.
|===


[[native-projection-syntax-node-projections]]
== Node projections

A node projection defines how a specific subset of Neo4j nodes is projected into the in-memory graph.

The following map-like syntax shows the general way of defining node projections:

[source]
----
{
    <node-label-1>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    },
    <node-label-2>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    },
    // ...
    <node-label-n>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    }
}
----

* `node-label-i` denotes the node label used in the projected graph
** `neo-label` denotes the name of the node label in the Neo4j graph
*** The label must exist in the Neo4j database
*** `neo-label` defaults to `node-label-i`
** `node-property-mappings` denotes a set of mappings between Neo4j and in-memory node properties

In the following example, we want to project `Person` and `City` nodes into the in-memory graph.

.Create a graph from multiple node labels:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph', {
        'Person': { label: 'Person' },
        'City': { label: 'City' }
    },

    '*'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

In the above example, we are using the same labels as in the Neo4j database.
In that case we can use the following syntactic sugar.

[source,cypher]
----
// Option 1
CALL gds.graph.create( 'my-graph', 'Person | City', '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;

// Option 2
CALL gds.graph.create( 'my-graph', ['Person', 'City'], '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

To project a Neo4j node label to a custom label, we can use syntactic sugar, too.
In the following example, we want to project the Neo4j label `Person` to the element identifier `Employee`.

[source,cypher]
----
CALL gds.graph.create( 'my-graph', [{Employee : 'Person'}, 'City'], '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

To project all nodes in the Neo4j graph, we can use the special `*` node projection.
This node projection can not be combined with any other node projection.

[source,cypher]
----
CALL gds.graph.create('my-graph', '*', '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

=== Node properties

We can load multiple node properties for each node projection using node property mappings.

The following map-like syntax shows the general way of defining node property mappings:

[source]
----
{
    <node-label-1>: {
        label: <neo-label>,
        properties: {
            <property-key-1>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            },
            <property-key-2>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            },
            // ...
            <property-key-n>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            }
        }
    }
}
----

* `property-key-i` denotes the name of the property in the projected graph
** `neo-property-key` denotes the name of the property in the Neo4j graph
*** The property key must exist in the Neo4j database
*** `neo-property-key` defaults to `property-key-i`
** `numeric-value` is used if the property does not exist for a node
*** `numeric-value` defaults to `NaN`

In the following example, we want to project `Person` and their properties nodes into the in-memory graph.

.Create a graph with multiple node properties:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph', {
        'City': {
            properties: {
                community: {
                    property: 'zipCode'
                },
                population: {
                    property: 'population'
                }
            }
        }
    },

    '*'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

If we want to load the same properties for each node label, we can use the following syntax sugar.

.Project node properties for multiple node labels:
[source,cypher]
----
CALL gds.graph.create( 'my-graph', 'City', '*', {
        nodeProperties: ['population', {community: 'zipCode'}]
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

The projected properties can be referred to by any algorithm that uses properties as input, for example, Label Propagation.

[source,cypher]
----
CALL gds.labelPropagation.stream(
    'my-graph', {
        seedProperty: 'community'
    }
)
----

[[native-projection-syntax-relationship-projections]]
== Relationship projections

A relationship projection defines how a specific subset of Neo4j relationships is projected into the in-memory graph.

The following map-like syntax shows the general way of defining relationship projections:

[source]
----
{
    <relationship-type-1>: {
        type: <neo-type>,
        projection: <projection-type>,
        aggregation: <aggregation-type>,
        properties: <relationship-property-mappings>
    },
    <relationship-type-2>: {
        type: <neo-type>,
        projection: <projection-type>,
        aggregation: <aggregation-type>,
        properties: <relationship-property-mappings>
    },
    // ...
    <relationship-type-n>: {
        type: <neo-type>,
        projection: <projection-type>,
        aggregation: <aggregation-type>,
        properties: <relationship-property-mappings>
    }
}
----

* `relationship-type-i` denotes the relationship type used in the projected graph
** `neo-type` denotes the name of the relationship type in the Neo4j graph
*** The relationship type must exist in the Neo4j database
*** `neo-type` defaults to `relationship-type-i`
** `projection-type` denotes how Neo4j relationships are represented in the projected graph.
    The following values are allowed:
*** `NATURAL`: each relationship is projected the same way as it is stored in Neo4j (default)
*** `REVERSE`: each relationship is reversed during graph projection
*** `UNDIRECTED`: each relationship is projected in both natural and reverse orientation
** `aggregation-type` denotes how parallel relationships and their properties are handled.
    The specified value is applied to all property mappings that have no aggregation specified.
    The following values are allowed:
*** `NONE`: parallel relationships are not aggregated (default)
*** `MIN`, `MAX`, `SUM`: applied to the numeric properties of parallel relationships
*** `SINGLE`: a single, arbitrary relationship out of the parallel relationships is projected
** `relationship-property-mappings` denotes a set of mappings between Neo4j and in-memory relationship properties


In the following example, we want to project `City` nodes and `ROAD` and `RAIL' relationships into the in-memory graph.

[source,cypher]
----
CALL gds.graph.create(
    'my-graph', 'City', {
        'ROAD': {
            type: 'ROAD',
            projection: 'NATURAL'
        },
        'RAIL': {
            type: 'RAIL',
            projection: 'NATURAL'
        }
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

In the above example, we are using the same relationship type as in the Neo4j database.
In that case we can use the following syntactic sugar.

[source,cypher]
----
// Option 1
CALL gds.graph.create( 'my-graph', 'City', 'ROAD | RAIL')
YIELD graphName, nodeCount, relationshipCount, createMillis;

// Option 2
CALL gds.graph.create( 'my-graph', 'City', ['ROAD', 'RAIL'])
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

Projecting multiple relationship types enables algorithms to only use a subset of those.

[source,cypher]
----
// Run on natural relationships
CALL gds.pageRank.stream('my-graph', { relationshipTypes: ['ROAD'] });

// Run on reversed relationships
CALL gds.pageRank.stream('my-graph', { relationshipTypes: ['RAIL'] });
----


=== Relationship aggregations

Relationship projections offer different ways of handling multiple - so called "parallel" - relationships between a given pair of nodes.
The default is the `NONE` aggregation which keeps all parallel relationships and directly projects them into the in-memory graph.
All other aggregations project all the parallel relationships between a pair of nodes into a single relationship.

=== Relationship properties

We can load multiple relationship properties for each relationship projection using relationship property mappings.

The following map-like syntax shows the general way of defining relationship property mappings:


[source]
----
{
    <relationship-type-1>: {
        type: <neo-type>,
        projection: <projection-type>,
        aggregation: <aggregation-type>,
        properties: {
            <property-key-1>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>,
                aggregation: <aggregation-type>
            },
            <property-key-2>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>,
                aggregation: <aggregation-type>
            },
            // ...
            <property-key-n>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>,
                aggregation: <aggregation-type>
            }
        }
    }
}
----

* `property-key-i` denotes the name of the property in the projected graph
** `neo-property-key` denotes the name of the property in the Neo4j graph
*** The property key must exist in the Neo4j database
*** `neo-property-key` defaults to `property-key-i`
** `numeric-value` is used if the property does not exist for a node
*** `numeric-value` defaults to `NaN`
** `aggregation-type` denotes how properties of parallel relationships are handled.
    The specified value override the aggregation type specified for the enclosing relationship projection.
    The following values are allowed:
*** `NONE`: parallel relationships are not aggregated (default)
*** `MIN`, `MAX`, `SUM`: applied to the numeric properties of parallel relationships
*** `SINGLE`: a single, arbitrary relationship out of the parallel relationships is projected


.Create a graph with multiple node and relationship properties:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph',
    {
        'City': {
            properties: {
                community: {
                    property: 'zipCode'
                },
                population: {
                    property: 'population'
                }
            }
        }
    },
    {
        'ROAD': {
            properties: {
                distance: {
                    aggregation: 'MIN'
                },
                quality: {
                    type: condition,
                    aggregation: 'MAX'
                }
            }
        }
    }

)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

//
//
// === Node-label and relationship-type projection
//
// By default, the Huge graph assumes that the relationship projection only contains one relationship between a pair of nodes and will simply ignore all other relationships (see `skip` below).
// In order to control the deduplication behavior we can pass the `duplicateRelationships` key in the config to decide what should happen with duplicates.
//
// `duplicateRelationships` supports the following options:
//
// * `none` - keeps all relationships between a given pair of nodes / no deduplication.
// * `skip` - keeps the first encountered relationship (and associated weight).
// * `sum` - sums the associated weights of all encountered relationships.
// * `min` - keeps the minimum weight of all encountered relationships.
// * `max` - keeps the maximum weight of all encountered relationships.
//
// Note that setting an explict deduplication strategy, other then `none` or `skip` will increase the relationship loading time.
//
// .The following query loads a graph of roads between locations keeping all the `ROAD` relationships between two `Loc` nodes.
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipWeight: 'cost',
//   duplicateRelationships: 'none'})
// ----
//
// .The following query loads a graph of roads between locations keeping only those `ROAD` relationships with the minimal cost.
// [source,cypher]
// ----
// CALL algo.graph.load('cheapestRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipWeight: 'cost',
//   duplicateRelationships: 'sum'})
// ----
// == Loading multiple node properties
//
// It is often useful to load an in-memory graph with more than one node property.
// A typical scenario is running different weighted algorithms on the same graph, but with different node properties as weight.
//
// For the `load.graph` procedure, loading multiple node properties can be configured via the `nodeProperties` parameter.
// The parameter is configured using a map in which each key refers to a user-defined property key.
// Any algorithm that supports node properties, for example for node weights or seed values, can refer to these user-defined property keys.
//
// The value under each property key is a configuration, that is applied when loading node properties.
// In the configuration we specify the Neo4j node property to load.
//
// For the following example, let's assume that each `City` node stores two properties: the `population` of the city and an optional `stateId` that identifies the state in which the city is located.
//
// .The following query loads all cities, including the two properties, since not all cities have a `stateId`, we set the `defaultValue` to `0`
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: {
//     population: {
//         property: 'population'
//     },
//     seedValue: {
//         property: 'stateId',
//         defaultValue: 0
//     }
//   }
// })
// ----
//
// We can refer to the loaded properties in each algorithm that supports reading node properties.
// For a path search algorithm, one could use the `population` as node weight whereas a clustering algorithm could use the `stateId` as seed value.
//
// We can also use the <<cypher-projection, Cypher projection>> to load multiple node properties.
// Here, the specified Neo4j node property must appear in the `RETURN` clause of the node query.
// If a property is not present on a node in Neo4j, the given default value is used instead.
//
// .The following query also loads all cities including their `population` and `stateId` properties
// [source,cypher]
// ----
// CALL gds.graph.create.cypher('cities',
//   'MATCH (c:City) RETURN id(c) AS id, c.population AS population, c.stateId AS stateId',
//   'MATCH (a:City)-->(b:City) RETURN id(a) AS sourceId, id(b) AS targetId',
//   {
//     nodeProperties: {
//       population: {
//           property: 'population'
//       },
//       seedValue: {
//           property: 'stateId',
//           defaultValue: 0
//       }
//   }
// })
// ----
//
// .If we just want to refer to the Neo4j node property key, we can use the following shorthand syntax:
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: {
//     population: 'population',
//     seedValue: 'stateId'
//   }
// })
// ----
//
// .We can also use the `nodeProperties` parameter to load a single node property:
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: 'population'
// })
// ----
//
//
// == Loading multiple relationship properties
//
// Similar to node properties, the `load.graph` procedure also supports loading multiple relationship properties.
// Those can be configured via the `relationshipProperties` parameter.
//
// As for nodes, the parameter is configured using a map in which each key refers to a user-defined property key.
// In addition to the Neo4j relationship property and an optional default value, we can define an aggregation function to set the deduplication behavior and a default property value which is used for absent property values (see <<deduplication-of-parallel-relationships>>).
//
// For the following example, let's assume that each `ROAD` relationship stores two properties: the `cost` (distance) and the road `quality` (between 1 and 10).
//
// .The following query loads all roads, deduplicates parallel relationships and aggregates them by their distance and also by their quality.
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipProperties: {
//     minDistance: {
//         property: 'cost',
//         aggregation: 'MIN',
//         defaultValue: 1.0
//     },
//     maxQuality: {
//         property: 'quality',
//         aggregation: 'MAX',
//         defaultValue: 5.0
//     }
//   }
// })
// ----
//
// When executed, our `allRoads` in-memory graph stores two relationship properties: `minDistance` and `maxQuality`.
// We can access the loaded properties by specifying them in an algorithm configuration.
// Let us use `gds.alpha.shortestPath` again as an example weighted algorithm.
//
// .We first compute the shortest path using the `minDistance` property as weight to compute the path with shortest distance:
// [source,cypher]
// ----
// MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
// CALL gds.alpha.shortestPath.write(
//   'allRoads',
//   {
//       startNode: start,
//       endNode: end,
//       weightProperty: 'minDistance'
//   }
// ) YIELD writeMillis, loadMillis, nodeCount, totalCost
// RETURN writeMillis, loadMillis, nodeCount, totalCost
// ----
//
// .We use the same graph, but the `maxQuality` property if we are interested in the path with the best quality:
// [source,cypher]
// ----
// MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
// CALL gds.alpha.shortestPath.write(
//   'allRoads',
//   {
//       startNode: start,
//       endNode: end,
//       weightProperty: 'maxQuality'
//   }
// ) YIELD writeMillis, loadMillis, nodeCount, totalCost
// RETURN writeMillis, loadMillis, nodeCount, totalCost
// ----
//
// With the short-hand syntax for specifying property mappings we can skip the `aggregation` and `defaultWeight` parameters.
// If those are omitted, the procedure uses `SKIP` as default aggregation function and `Double.NaN` as default property value.
//
// .The following query loads the graph and allows us to refer to the `cost` property via `distance`:
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipProperties: { distance: 'cost' }
// })
// ----
//
// Note that in this particular shortest path example, using the default property value is not recommended.
//
// [NOTE]
// ====
// Loading multiple relationship properties is currently only supported for node-label and relationship-type projections.
// ====
//
// [CAUTION]
// ====
// As with relationship types, loading a lot of multiple relationship properties can have a negative impact on performace, both during load and execution time.
// It is best to only load as few properties as needed.
// ====