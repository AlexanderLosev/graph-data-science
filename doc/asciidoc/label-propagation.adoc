[[algorithms-label-propagation]]
= The Label Propagation algorithm

[abstract]
--
This section describes the Label Propagation algorithm in the Neo4j Graph Algorithms library.
--

// tag::introduction[]
The Label Propagation algorithm (LPA) is a fast algorithm for finding communities in a graph.
It detects these communities using network structure alone as its guide, and doesn't require a pre-defined objective function or prior information about the communities.

One interesting feature of LPA is that nodes can be assigned preliminary labels to narrow down the range of solutions generated.
This means that it can be used as semi-supervised way of finding communities where we hand-pick some initial communities.
// end::introduction[]

This section includes:

* <<algorithms-label-propagation-intro, Introduction>>
* <<algorithms-label-propagation-syntax, Syntax>>
* <<algorithms-label-propagation-examples, Examples>>
** <<algorithms-label-propagation-examples-unweighted, Unweighted>>
//** <<algorithms-label-propagation-examples-weighted, Weighted>>
** <<algorithms-label-propagation-examples-seeded, Seeded>>
** <<algorithms-label-propagation-examples-projection, Named graphs and Cypher projections>>

[[algorithms-label-propagation-intro]]
== Introduction

LPA works by propagating labels throughout the network and forming communities based on this process of label propagation.

The intuition behind the algorithm is that a single label can quickly become dominant in a densely connected group of nodes, but will have trouble crossing a sparsely connected region.
Labels will get trapped inside a densely connected group of nodes, and those nodes that end up with the same label when the algorithms finish can be considered part of the same community.

// tag::formula[]
The algorithm works as follows:

* Every node is initialized with a unique community label (an identifier).
* These labels propagate through the network.
* At every iteration of propagation, each node updates its label to the one that the maximum numbers of its neighbours belongs to.
  Ties are broken uniformly and randomly.
* LPA reaches convergence when each node has the majority label of its neighbours.
* LPA stops if either convergence or the user-defined maximum number of iterations is achieved.

As labels propagate, densely connected groups of nodes quickly reach a consensus on a unique label.
At the end of the propagation only a few labels will remain - most will have disappeared.
Nodes that have the same community label at convergence are said to belong to the same community.
// end::formula[]

For more information on this algorithm, see:

* https://arxiv.org/pdf/0709.2938.pdf["Near linear time algorithm to detect community structures in large-scale networks"^]
* Use cases:
** https://dl.acm.org/citation.cfm?id=2140465[Twitter polarity classification with label propagation over lexical links and the follower graph]
** https://www.nature.com/articles/srep12339[Label Propagation Prediction of Drug-Drug Interactions Based on Clinical Side Effects]
** https://www.uni-ulm.de/fileadmin/website_uni_ulm/iui.iwsds2017/papers/IWSDS2017_paper_12.pdf["Feature Inference Based on Label Propagation on Wikidata Graph for DST"]

[NOTE]
====
Running this algorithm requires sufficient memory availability.
Before running this algorithm, we recommend that you read <<memory-requirements>>.
====

[[algorithms-label-propagation-syntax]]
== Syntax

.The following will run the algorithm and write back results:
[source, cypher]
----
CALL algo.labelPropagation(label:String, relationship:String, {iterations:10,
    weightProperty:'weight', writeProperty:'community', write:true, concurrency:4})
YIELD nodes, iterations, didConverge, loadMillis, computeMillis, writeMillis, write, weightProperty, writeProperty
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name              | Type    | Default        | Optional | Description
| node label        | string  | null           | yes      | The label to load from the graph. If null, load all nodes.
| relationship type | string  | null           | yes      | The relationship type to load from the graph. If null, load all relationships.
| direction         | string  | 'OUTGOING'     | yes      | The relationship-direction to use in the algorithm.
| config            | map     | n/a            | yes      | Additional configuration.
|===

.Configuration
[opts="header",cols="1,1,1,1,4"]
|===
| Name              | Type    | Default                | Optional | Description
| direction         | string  | 'OUTGOING'             | yes      | The relationship-direction to use in the algorithm.
| iterations        | int     | 10                     | yes      | The maximum number of iterations to run.
| concurrency       | int     | available CPUs         | yes      | The number of concurrent threads used for running the algorithm. Also provides the default value for 'readConcurrency' and 'writeConcurrency'.
| readConcurrency   | int     | value of 'concurrency' | yes      | The number of concurrent threads used for reading the graph.
| writeConcurrency  | int     | value of 'concurrency' | yes      | The number of concurrent threads used for writing the result.
| weightProperty    | string  | 'weight'               | yes      | The property name of node and/or relationship that contain weight. Must be numeric.
| seedProperty      | string  | n/a                    | yes      | Used to define initial set of labels (must be a number).
| partitionProperty | string  | n/a                    | yes      | Deprecated. Replaced by 'seedProperty'.
| writeProperty     | string  | n/a                    | yes      | The property name written back to the partition of the graph in which the node resides.
| write             | boolean | true                   | yes      | Specifies if the result should be written back as a node property.
| graph             | string  | 'huge'                 | yes      | Use 'huge' when describing the subset of the graph with label and relationship-type parameter. Use 'cypher' for describing the subset with cypher node statement and relationship statement.
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name | Type | Description
| loadMillis | int | Milliseconds for loading data.
| computeMillis | int | Milliseconds for running the algorithm.
| writeMillis | int | Milliseconds for writing result data back.
| postProcessingMillis    | int  | Milliseconds for computing percentiles and community count.

| nodes | int | The number of nodes considered.
| communityCount | int  | The number of communities found.
| iterations | int | The number of iterations that were executed.
| didConverge | boolean | True if the algorithm did converge to a stable labelling within the provided number of maximum iterations.

| p1                   | double  | The 1 percentile of community size.
| p5                   | double  | The 5 percentile of community size.
| p10                   | double  | The 10 percentile of community size.
| p25                   | double  | The 25 percentile of community size.
| p50                   | double  | The 50 percentile of community size.
| p75                   | double  | The 75 percentile of community size.
| p90                   | double  | The 90 percentile of community size.
| p95                   | double  | The 95 percentile of community size.
| p99                   | double  | The 99 percentile of community size.
| p100                  | double  | The 100 percentile of community size.

| write | boolean | Specifies if the result was written back as a node property.
| writeProperty | string | The property name written back to.
| weightProperty | string | The property name that contains weight.

|===

.Or use the beta procedure:
[source, cypher]
----
CALL algo.beta.labelPropagation(label:String, relationship:String, {iterations:10,
    weightProperty:'weight', writeProperty:'community', write:true, concurrency:4})
YIELD nodes, ranIterations, didConverge, loadMillis, computeMillis, writeMillis, write, weightProperty, writeProperty
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name              | Type    | Default        | Optional | Description
| node label        | string  | null           | yes      | The label to load from the graph. If null, load all nodes.
| relationship type | string  | null           | yes      | The relationship type to load from the graph. If null, load all relationships.
| config            | map     | n/a            | yes      | Additional configuration.
|===

.Configuration
[opts="header",cols="1,1,1,1,4"]
|===
| Name              | Type    | Default                | Optional | Description
| direction         | string  | 'OUTGOING'             | yes      | The relationship-direction to use in the algorithm.
| iterations        | int     | 10                     | yes      | The maximum number of iterations to run.
| concurrency       | int     | available CPUs         | yes      | The number of concurrent threads used for running the algorithm. Also provides the default value for 'readConcurrency' and 'writeConcurrency'.
| readConcurrency   | int     | value of 'concurrency' | yes      | The number of concurrent threads used for reading the graph.
| writeConcurrency  | int     | value of 'concurrency' | yes      | The number of concurrent threads used for writing the result.
| weightProperty    | string  | 'weight'               | yes      | The property name of node and/or relationship that contain weight. Must be numeric.
| seedProperty      | string  | n/a                    | yes      | Used to define initial set of labels (must be a number).
| partitionProperty | string  | n/a                    | yes      | Deprecated. Replaced by `seedProperty`.
| writeProperty     | string  | n/a                    | yes      | The property name written back to the partition of the graph in which the node resides.
| write             | boolean | true                   | yes      | Specifies if the result should be written back as a node property.
| graph             | string  | 'huge'                 | yes      | Use 'huge' when describing the subset of the graph with label and relationship-type parameter. Use 'cypher' for describing the subset with cypher node statement and relationship statement.
|===

.Results
[opts="header",cols="1,1,6"]
|===
| Name | Type | Description
| loadMillis | int | Milliseconds for loading data.
| computeMillis | int | Milliseconds for running the algorithm.
| writeMillis | int | Milliseconds for writing result data back.
| postProcessingMillis    | int  | Milliseconds for computing percentiles and community count.

| nodes | int | The number of nodes considered.
| communityCount | int  | The number of communities found.
| ranIterations | int | The number of iterations that were executed.
| didConverge | boolean | True if the algorithm did converge to a stable labelling within the provided number of maximum iterations.

| p1                   | double  | The 1 percentile of community size.
| p5                   | double  | The 5 percentile of community size.
| p10                   | double  | The 10 percentile of community size.
| p25                   | double  | The 25 percentile of community size.
| p50                   | double  | The 50 percentile of community size.
| p75                   | double  | The 75 percentile of community size.
| p90                   | double  | The 90 percentile of community size.
| p95                   | double  | The 95 percentile of community size.
| p99                   | double  | The 99 percentile of community size.
| p100                  | double  | The 100 percentile of community size.

| write | boolean | Specifies if the result was written back as a node property.
| writeProperty | string | The property name written back to.
| weightProperty | string | The property name that contains weight.

|===

.The following will run the algorithm and stream back results:
[source,cypher]
----
CALL algo.labelPropagation.stream(label:String, relationship:String, {iterations:10,
    weightProperty:'weight', writeProperty:'partition', concurrency:4, direction:'OUTGOING'})
YIELD nodeId, label
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name              | Type    | Default        | Optional | Description
| node label        | string  | null           | yes      | The label to load from the graph. If null, load all nodes.
| relationship type | string  | null           | yes      | The relationship type to load from the graph. If null, load all relationships.
| config            | map     | n/a            | yes      | Additional configuration.
|===

.Configuration
[opts="header",cols="1,1,1,1,4"]
|===
| Name              | Type   | Default                | Optional | Description
| direction         | string | 'OUTGOING'             | yes      | The relationship-direction to use in the algorithm.
| iterations        | int    | 10                     | yes      | The maximum number of iterations to run.
| concurrency       | int    | available CPUs         | yes      | The number of concurrent threads used for running the algorithm. Also provides the default value for 'readConcurrency'.
| readConcurrency   | int    | value of 'concurrency' | yes      | The number of concurrent threads used for reading the graph.
| weightProperty    | string | 'weight'               | yes      | The property name of node and/or relationship that contain weight. Must be numeric.
| seedProperty      | string | n/a                    | yes      | Used to define initial set of labels (must be a number).
| partitionProperty | string | n/a                    | yes      | Deprecated. Replaced by `seedProperty`.
| graph             | string | 'huge'                 | yes      | Use 'huge' when describing the subset of the graph with label and relationship-type parameter. Use 'cypher' for describing the subset with cypher node statement and relationship statement.
|===

.Results
[opts="header"]
|===
| Name   | Type | Description
| nodeId | int  | Node ID
| label  | int  | Community ID
|===


ifndef::env-docs[]

[[algorithms-label-propagation-examples]]
== Examples

Consider the graph created by the following Cypher statement:

[source, cypher]
----
CREATE (nAlice:User {name:'Alice', seed_label:52})
CREATE (nBridget:User {name:'Bridget', seed_label:21})
CREATE (nCharles:User {name:'Charles', seed_label:43})
CREATE (nDoug:User {name:'Doug', seed_label:21})
CREATE (nMark:User {name:'Mark', seed_label:19})
CREATE (nMichael:User {name:'Michael', seed_label:52})

CREATE (nAlice)-[:FOLLOW]->(nBridget)
CREATE (nAlice)-[:FOLLOW]->(nCharles)
CREATE (nMark)-[:FOLLOW]->(nDoug)
CREATE (nBridget)-[:FOLLOW]->(nMichael)
CREATE (nDoug)-[:FOLLOW]->(nMark)
CREATE (nMichael)-[:FOLLOW]->(nAlice)
CREATE (nAlice)-[:FOLLOW]->(nMichael)
CREATE (nBridget)-[:FOLLOW]->(nAlice)
CREATE (nMichael)-[:FOLLOW]->(nBridget)
CREATE (nCharles)-[:FOLLOW]->(nDoug);
----

// TODO: graph explanation

[[algorithms-label-propagation-examples-unweighted]]
=== Unweighted

.The following will run the algorithm and stream results:
[source, cypher]
----
CALL algo.labelPropagation.stream("User", "FOLLOW", {
  direction: "OUTGOING",
  iterations: 10
})
YIELD nodeId AS Name, label AS name
RETURN algo.asNode(nodeId).name AS Name, label AS CommunityId
  ORDER BY CommunityId, Name
----

// tag::stream-sample-graph-result[]
.Results
[opts="header",cols="1,1"]
|===
| Name    | CommunityId
| "Alice"   | 1
| "Bridget" | 1
| "Charles" | 1
| "Doug"    | 4
| "Mark"    | 4
| "Michael" | 4
|===
// end::stream-sample-graph-result[]

.The following will load the graph, run the algorithm, and write back results:
[source, cypher]
----
CALL algo.labelPropagation('User', 'FOLLOW', {
  iterations: 10,
  writeProperty: 'community',
  write: true,
  direction: 'OUTGOING'})
YIELD nodes, iterations, communityCount, writeProperty;
----

.Results
[opts="header",cols="1m,1m,1m,1m"]
|===
| nodes | iterations | communityCount | PropertyName
| 6     | 3          | 2               | "componentId"
|===


// tag::stream-sample-graph-explanation[]
Our algorithm found two communities, with 3 members each.

It appears that Michael, Bridget, and Alice belong together, as do Doug and Mark.
Only Charles doesn't strongly fit into either side, but ends up with Doug and Mark.
// end::stream-sample-graph-explanation[]

// TODO: add weights to graph and create example
//[[algorithms-label-propagation-examples-weighted]]
//=== Weighted

[[algorithms-label-propagation-examples-seeded]]
=== Seeded

At the beginning of the algorithm, every node is initialized with a unique label and the labels propagate through the network.

It is possible to define preliminary labels of nodes using the `seedProperty` parameter.
We need to store a preliminary set of labels that we would like to run the Label Propagation algorithm with as node properties.
That property needs to be a number.
In our example graph we saved them as the property `seed_label`.

The algorithm first checks if there is a seed label assigned to the node, and loads it if there is one.
If there isn't one, it assigns a new unique label to the node.
Using this preliminary set of labels, it then sequentially updates each node's label to a new one, which is the most frequent label among its neighbors at every iteration of label propagation.

.The following will run the algorithm with pre-defined labels:
[source, cypher]
----
CALL algo.labelPropagation.stream('User', 'FOLLOW', {
  iterations: 10,
  seedProperty: 'seed_label',
  direction: 'OUTGOING'
})
YIELD nodeId AS Name, label AS name
RETURN algo.asNode(nodeId).name AS Name, label AS CommunityId
  ORDER BY CommunityId, Name
----

.Results
[opts="header",cols="1,1"]
|===
| Name    | CommunityId
| "Alice"   | 19
| "Bridget" | 19
| "Charles" | 19
| "Doug"    | 21
| "Mark"    | 21
| "Michael" | 21
|===

// TODO: explain result

[[algorithms-label-propagation-examples-projection]]
=== Cypher projection

In the examples above, we have relied on the _implicit_ loading of graphs for the algorithm computation.
However, like other algorithms WCC also accepts _named graphs_ and _Cypher projections_ as inputs.
See <<projected-graph-model, Projected Graph Model>> for more details.

.Using a named graph:
[source, cypher]
----
CALL algo.graph.load('myGraph', 'User', 'FOLLOW');

CALL algo.labelPropagation.stream(null, null, {graph: 'myGraph'})
YIELD nodeId, label
RETURN algo.asNode(nodeId).name AS Name, label AS ComponentId
ORDER BY ComponentId, Name;
----

.Results
[opts="header",cols="1,1"]
|===
| Name    | Community
| Alice   | 5
| Charles | 4
| Bridget | 5
| Michael | 5
| Doug    | 4
| Mark    | 4
|===

As we can see, the results are identical to the results in the <<algorithms-label-propagation-examples-unweighted>> example.

.Set `graph:'cypher'` in the config:
[source, cypher]
----
CALL algo.labelPropagation.stream(
  'MATCH (p:User) RETURN id(p) AS id, p.weight AS weight, id(p) AS value',
  'MATCH (p1:User)-[f:FOLLOW]->(p2:User)
   RETURN id(p1) AS source, id(p2) AS target, f.weight AS weight', {
  graph: 'cypher',
  direction: "OUTGOING",
  iterations: 10
})
YIELD nodeId, label
RETURN algo.asNode(nodeId).name AS Name, label AS ComponentId
ORDER BY ComponentId, Name;
----

.Results
[opts="header",cols="1,1"]
|===
| Name    | Community
| Alice   | 5
| Charles | 4
| Bridget | 5
| Michael | 5
| Doug    | 4
| Mark    | 4
|===

Again, results are identical, as the Cypher projection we use mimics the behaviour of the default loading configuration.
Of course, the Cypher projection feature enables more advanced control over which exact parts of the graph to compute over; please see <<cypher-projection>> for more details.


