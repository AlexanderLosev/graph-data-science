[[labs-procedures]]
= Procedures

[abstract]
--
This chapter contains a reference of procedures for using the experimental algorithms in the Neo4j Graph Algorithms library.
--

The following is a procedure reference for calling the experimental algorithms in the Neo4j Graph Algorithms library.

[[table-experimental]]
[opts=header,cols="1m,5m"]
|===
| Name                                                                                                     | Description
| <<algorithm-all-pairs-shortest-path-sample, algo.allShortestPaths.stream>>                               | CALL algo.allShortestPaths.stream(weightProperty:String{nodeQuery:'labelName', relationshipQuery:'relationshipName', defaultValue:1.0, concurrency:4}) YIELD sourceNodeId, targetNodeId, distance - yields a stream of {sourceNodeId, targetNodeId, distance}
| algo.asNode                                                                                              | CALL algo.asNode(value) - return node for nodeId. null if none exists
| algo.asNodes                                                                                             | CALL algo.asNodes(values) - return nodes for nodeIds. empty if none exists
| algo.asPath                                                                                              | CALL algo.asPath - returns a path for the provided node ids and weights
| <<algorithms-articlerank-syntax, algo.articleRank>>                                                      | CALL algo.articleRank(label:String, relationship:String, {iterations:5, dampingFactor:0.85, weightProperty: null, write: true, writeProperty:'articlerank', concurrency:4}) YIELD nodes, iterations, loadMillis, computeMillis, writeMillis, dampingFactor, write, writeProperty - calculates page rank and potentially writes back
| <<algorithms-articlerank-syntax, algo.articleRank.stream>>                                               | CALL algo.articleRank.stream(label:String, relationship:String, {iterations:20, dampingFactor:0.85, weightProperty: null, concurrency:4}) YIELD node, score - calculates page rank and streams results
| algo.bfs.stream                                                                                          | CALL algo.bfs.stream(label:String, relationshipType:String, startNodeId:long, direction:Direction, {writeProperty:String, target:long, maxDepth:long, weightProperty:String, maxCost:double}) YIELD nodeId
| <<algorithms-balanced-triads-syntax, algo.balancedTriads>>                                               | CALL algo.balancedTriads(label, relationship{concurrency:4, write:true, weightProperty:'w', balancedProperty:'balanced', unbalancedProperty:'unbalanced'}) YIELD loadMillis, computeMillis, writeMillis, nodeCount, balancedTriadCount, unbalancedTriadCount
| <<algorithms-balanced-triads-syntax, algo.balancedTriads.stream>>                                        | CALL algo.balancedTriads.stream(label, relationship, {concurrency:8}) YIELD nodeId, balanced, unbalanced
| <<algorithms-harmonic-centrality-syntax, algo.closeness.harmonic>>                                       | CALL algo.closeness.harmonic(label:String, relationship:String, {write:true, writeProperty:'centrality, concurrency:4'}) YIELD loadMillis, computeMillis, writeMillis, nodes] - yields evaluation details
| <<algorithms-harmonic-centrality-syntax, algo.closeness.harmonic.stream>>                                | CALL algo.closeness.harmonic.stream(label:String, relationship:String{concurrency:4}) YIELD nodeId, centrality - yields centrality for each node
| algo.closeness.dangalchev                                                                                | CALL algo.closeness.dangalchev(label:String, relationship:String, {write:true, writeProperty:'centrality, concurrency:4'}) YIELD loadMillis, computeMillis, writeMillis, nodes] - yields evaluation details
| algo.closeness.dangalchev.stream                                                                         | CALL algo.closeness.dangalchev.stream(label:String, relationship:String{concurrency:4}) YIELD nodeId, centrality - yields centrality for each node
| algo.dfs.stream                                                                                          | CALL algo.dfs.stream(label:String, relationshipType:String, startNodeId:long, direction:Direction, {writeProperty:String, target:long, maxDepth:long, weightProperty:String, maxCost:double}) YIELD nodeId
| <<algorithms-eigenvector-syntax, algo.eigenvector>>                                                      | CALL algo.eigenvector(label:String, relationship:String, {weightProperty: null, write: true, writeProperty:'eigenvector', concurrency:4}) YIELD nodes, iterations, loadMillis, computeMillis, writeMillis, dampingFactor, write, writeProperty - calculates eigenvector centrality and potentially writes back
| <<algorithms-eigenvector-syntax, algo.eigenvector.stream>>                                               | CALL algo.eigenvector.stream(label:String, relationship:String, {weightProperty: null, concurrency:4}) YIELD node, score - calculates eigenvector centrality and streams results
| algo.getNodeById                                                                                         | CALL algo.getNodeById(value) - return node for nodeId. null if none exists
| algo.getNodesById                                                                                        | CALL algo.getNodesById(values) - return nodes for nodeIds. empty if none exists
| algo.infoMap                                                                                             | TODO
| algo.Infinity                                                                                            | CALL algo.Infinity() - returns Double.POSITIVE_INFINITY as a value.
| algo.isFinite                                                                                            | CALL algo.isFinite(value) - return true iff the given argument is a finite value (not ±Infinity, NaN, or null), false otherwise.
| algo.isInfinite                                                                                          | CALL algo.isInfinite(value) - return true iff the given argument is not a finite value (±Infinity, NaN, or null), false otherwise.
| <<algorithms-yens-k-shortest-path-syntax, algo.kShortestPaths>>                                          | CALL algo.kShortestPaths(startNode:Node, endNode:Node, k:int, weightProperty:String{nodeQuery:'labelName', relationshipQuery:'relationshipName', direction:'OUT', defaultValue:1.0, maxDepth:42, write:'true', writePropertyPrefix:'PATH_'}) YIELD resultCount, loadMillis, evalMillis, writeMillis - yields resultCount, loadMillis, evalMillis, writeMillis
| <<algorithms-yens-k-shortest-path-syntax, algo.kShortestPaths.stream>>                                   | CALL algo.kShortestPaths.stream(startNode:Node, endNode:Node, k:int, weightProperty:String{nodeQuery:'labelName', relationshipQuery:'relationshipName', direction:'OUT', defaultValue:1.0, maxDepth:42}) YIELD sourceNodeId, targetNodeId, nodeIds, costs
| <<algorithms-linkprediction-adamic-adar-syntax, algo.linkprediction.adamicAdar>>                         | algo.linkprediction.adamicAdar(node1:Node, node2:Node, {relationshipQuery:'relationshipName', direction:'BOTH'}) given two nodes, calculate Adamic Adar similarity
| <<algorithms-linkprediction-common-neighbors-syntax, algo.linkprediction.commonNeighbors>>               | algo.linkprediction.commonNeighbors(node1:Node, node2:Node, {relationshipQuery:'relationshipName', direction:'BOTH'}) given two nodes, returns the number of common neighbors
| <<algorithms-linkprediction-preferential-attachment-syntax, algo.linkprediction.preferentialAttachment>> | algo.linkprediction.preferentialAttachment(node1:Node, node2:Node, {relationshipQuery:'relationshipName', direction:'BOTH'}) given two nodes, calculate Preferential Attachment
| <<algorithms-linkprediction-resource-allocation-syntax, algo.linkprediction.resourceAllocation>>         | algo.linkprediction.resourceAllocation(node1:Node, node2:Node, {relationshipQuery:'relationshipName', direction:'BOTH'}) given two nodes, calculate Resource Allocation similarity
| <<algorithms-linkprediction-same-community-syntax, algo.linkprediction.sameCommunity>>                   | algo.linkprediction.sameCommunity(node1:Node, node2:Node, communityProperty: String) given two nodes, indicates if they have the same community
| <<algorithms-linkprediction-total-neighbors-syntax, algo.linkprediction.totalNeighbors>>                 | algo.linkprediction.totalNeighbors(node1:Node, node2:Node, {relationshipQuery:'relationshipName', direction:'BOTH'}) given two nodes, calculate Total Neighbors
| <<labs-algorithms-one-hot-encoding, algo.ml.oneHotEncoding>>                                     | CALL algo.ml.oneHotEncoding(availableValues, selectedValues) - return a list of selected values in a one hot encoding format.
| algo.mst                                                                                                 | CALL algo.mst(label:String, relationshipType:String, weightProperty:String, startNodeId:long, {writeProperty:String}) YIELD loadMillis, computeMillis, writeMillis, effectiveNodeCount
| algo.NaN                                                                                                 | CALL algo.NaN() - returns Double.NaN as a value.
| <<algorithms-random-walk-syntax, algo.randomWalk.stream>>                                                | CALL algo.randomWalk.stream(start:null=all/[ids]/label, steps, walks, {graph: 'huge/cypher', nodeQuery:nodeLabel/query, relationshipQuery:relType/query, mode:random/node2vec, return:1.0, inOut:1.0, path:false/true concurrency:4, direction:'BOTH'}) YIELD nodes, path - computes random walks from given starting points
| <<algorithms-strongly-connected-components-syntax, algo.scc>>                                            | CALL algo.scc(label:String, relationship:String, config:Map<String, Object>) YIELD loadMillis, computeMillis, writeMillis, setCount, maxSetSize, minSetSize
| <<algorithms-strongly-connected-components-syntax, algo.scc.stream>>                                     | CALL algo.scc.stream(label:String, relationship:String, config:Map<String, Object>) YIELD loadMillis, computeMillis, writeMillis, setCount, maxSetSize, minSetSize
| <<algorithms-strongly-connected-components-syntax, algo.scc.forwardBackward.stream>>                     | CALL algo.scc.forwardBackward.stream(long startNodeId, label:String, relationship:String, {write:true, concurrency:4}) YIELD nodeId, partition
| <<algorithms-strongly-connected-components-syntax, algo.scc.multistep>>                                  | CALL algo.scc.multistep(label:String, relationship:String, {write:true, concurrency:4, cutoff:100000}) YIELD loadMillis, computeMillis, writeMillis, setCount, maxSetSize, minSetSize
| <<algorithms-strongly-connected-components-syntax, algo.scc.multistep.stream>>                           | CALL algo.scc.multistep.stream(label:String, relationship:String, {write:true, concurrency:4, cutoff:100000}) YIELD nodeId, partition
| <<algorithms-strongly-connected-components-syntax, algo.scc.iterative>>                                  | CALL algo.scc.iterative(label:String, relationship:String, config:Map<String, Object>) YIELD loadMillis, computeMillis, writeMillis, setCount, maxSetSize, minSetSize
| <<algorithms-strongly-connected-components-syntax, algo.scc.iterative.stream>>                           | CALL algo.scc.iterative.stream(label:String, relationship:String, config:Map<String, Object>) YIELD nodeId, partition
| <<algorithms-strongly-connected-components-syntax, algo.scc.recursive.tarjan>>                           | CALL algo.scc.tarjan(label:String, relationship:String, config:Map<String, Object>) YIELD loadMillis, computeMillis, writeMillis, setCount, maxSetSize, minSetSize
| <<algorithms-strongly-connected-components-syntax, algo.scc.recursive.tunedTarjan>>                      | CALL algo.scc.recursive.tunedTarjan(label:String, relationship:String, config:Map<String, Object>) YIELD loadMillis, computeMillis, writeMillis, setCount, maxSetSize, minSetSize
| <<algorithms-strongly-connected-components-syntax, algo.scc.recursive.tunedTarjan.stream>>               | CALL algo.scc.recursive.tunedTarjan.stream(label:String, relationship:String, config:Map<String, Object>) YIELD nodeId, partition
| <<algorithms-shortest-path-syntax, algo.shortestPath>>                                                   | CALL algo.shortestPath(startNode:Node, endNode:Node, weightProperty:String{nodeQuery:'labelName', relationshipQuery:'relationshipName', direction:'BOTH', defaultValue:1.0, write:'true', writeProperty:'sssp'}) YIELD nodeId, cost, loadMillis, evalMillis, writeMillis - yields nodeCount, totalCost, loadMillis, evalMillis, writeMillis
| <<algorithms-shortest-path-syntax, algo.shortestPath.stream>>                                            | CALL algo.shortestPath.stream(startNode:Node, endNode:Node, weightProperty:String{nodeQuery:'labelName', relationshipQuery:'relationshipName', direction:'BOTH', defaultValue:1.0}) YIELD nodeId, cost - yields a stream of {nodeId, cost} from start to end (inclusive)
| <<algorithms-a_star-syntax, algo.shortestPath.astar.streamm>>                                            | CALL algo.shortestPath.astar.stream(startNode:Node, endNode:Node, weightProperty:String, propertyKeyLat:String,propertyKeyLon:String, {nodeQuery:'labelName', relationshipQuery:'relationshipName', direction:'BOTH', defaultValue:1.0}) YIELD nodeId, cost - yields a stream of {nodeId, cost} from start to end (inclusive)
| <<algorithms-single-source-shortest-path-syntax, algo.shortestPath.deltaStepping>>                       | CALL algo.shortestPath.deltaStepping(startNode:Node, weightProperty:String, delta:Double{label:'labelName', relationship:'relationshipName', defaultValue:1.0, write:true, writeProperty:'sssp'}) YIELD loadDuration, evalDuration, writeDuration, nodeCount
| <<algorithms-single-source-shortest-path-syntax, algo.shortestPath.deltaStepping.stream>>                | CALL algo.shortestPath.deltaStepping.stream(startNode:Node, weightProperty:String, delta:Double{label:'labelName', relationship:'relationshipName', defaultValue:1.0, concurrency:4}) YIELD nodeId, distance - yields a stream of {nodeId, distance} from start to end (inclusive)
| <<algorithms-similarity-cosine-syntax, algo.similarity.cosine>>                                          | CALL algo.similarity.cosine([{item:id, weights:[weights]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD p50, p75, p90, p99, p999, p100 - computes cosine similarities
| <<algorithms-similarity-cosine-syntax, algo.similarity.cosine>>                                          | algo.similarity.cosine([vector1], [vector2]) given two collection vectors, calculate cosine similarity
| <<algorithms-similarity-cosine-syntax, algo.similarity.cosine.stream>>                                   | CALL algo.similarity.cosine.stream([{item:id, weights:[weights]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD item1, item2, count1, count2, intersection, similarity - computes cosine distance
| <<algorithms-similarity-euclidean-syntax, algo.similarity.euclidean>>                                    | CALL algo.similarity.euclidean([{item:id, weights:[weights]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD p50, p75, p90, p99, p999, p100 - computes euclidean similarities
| <<algorithms-similarity-euclidean-syntax, algo.similarity.euclidean>>                                    | algo.similarity.euclidean([vector1], [vector2]) given two collection vectors, calculate similarity based on euclidean distance
| <<algorithms-similarity-euclidean-syntax, algo.similarity.euclidean.stream>>                             | CALL algo.similarity.euclidean.stream([{item:id, weights:[weights]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD item1, item2, count1, count2, intersection, similarity - computes euclidean distance
| algo.similarity.euclideanDistance                                                                        | algo.similarity.euclideanDistance([vector1], [vector2]) given two collection vectors, calculate the euclidean distance (square root of the sum of the squared differences)
| <<algorithms-similarity-jaccard-syntax, algo.similarity.jaccard>>                                        | algo.similarity.jaccard([vector1], [vector2]) given two collection vectors, calculate jaccard similarity
| <<algorithms-similarity-jaccard-syntax, algo.similarity.jaccard>>                                        | CALL algo.similarity.jaccard([{item:id, categories:[ids]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD p50, p75, p90, p99, p999, p100 - computes jaccard similarities
| <<algorithms-similarity-overlap-syntax, algo.similarity.overlap>>                                        | algo.similarity.overlap([vector1], [vector2]) given two collection vectors, calculate overlap similarity
| <<algorithms-similarity-overlap-syntax, algo.similarity.overlap>>                                        | CALL algo.similarity.overlap([{item:id, targets:[ids]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD p50, p75, p90, p99, p999, p100 - computes overlap similarities
| <<algorithms-similarity-overlap-syntax, algo.similarity.overlap.stream>>                                 | CALL algo.similarity.overlap.stream([{item:id, targets:[ids]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD item1, item2, count1, count2, intersection, similarity - computes overlap similarities
| <<algorithms-similarity-pearson-syntax, algo.similarity.pearson>>                                        | algo.similarity.pearson([vector1], [vector2]) given two collection vectors, calculate pearson similarity
| <<algorithms-similarity-pearson-syntax, algo.similarity.pearson>>                                        | CALL algo.similarity.pearson([{item:id, weights:[weights]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD p50, p75, p90, p99, p999, p100 - computes cosine similarities
| <<algorithms-similarity-pearson-syntax, algo.similarity.pearson.stream>>                                 | CALL algo.similarity.pearson.stream([{item:id, weights:[weights]}], {similarityCutoff:-1,degreeCutoff:0}) YIELD item1, item2, count1, count2, intersection, similarity - computes cosine distance
| <<algorithms-minimum-weight-spanning-tree-syntax, algo.spanningTree>>                                    | CALL algo.spanningTree(label:String, relationshipType:String, weightProperty:String, startNodeId:long, {writeProperty:String}) YIELD loadMillis, computeMillis, writeMillis, effectiveNodeCount
| <<algorithms-minimum-weight-spanning-tree-syntax, algo.spanningTree.kmax>>                               | CALL algo.spanningTree.kmax(label:String, relationshipType:String, weightProperty:String, startNodeId:long, k:int, {writeProperty:String}) YIELD loadMillis, computeMillis, writeMillis, effectiveNodeCount
| <<algorithms-minimum-weight-spanning-tree-syntax, algo.spanningTree.kmin>>                               | CALL algo.spanningTree.kmin(label:String, relationshipType:String, weightProperty:String, startNodeId:long, k:int, {writeProperty:String}) YIELD loadMillis, computeMillis, writeMillis, effectiveNodeCount
| <<algorithms-minimum-weight-spanning-tree-syntax, algo.spanningTree.maximum>>                            | CALL algo.spanningTree.maximum(label:String, relationshipType:String, weightProperty:String, startNodeId:long, {writeProperty:String}) YIELD loadMillis, computeMillis, writeMillis, effectiveNodeCount
| <<algorithms-minimum-weight-spanning-tree-syntax, algo.spanningTree.minimum>>                            | CALL algo.spanningTree.minimum(label:String, relationshipType:String, weightProperty:String, startNodeId:long, {writeProperty:String}) YIELD loadMillis, computeMillis, writeMillis, effectiveNodeCount
| <<algorithms-triangle-count-clustering-coefficient-syntax, algo.triangle.stream>>                        | CALL algo.triangle.stream(label, relationship, {concurrency:4}) YIELD nodeA, nodeB, nodeC - yield nodeA, nodeB and nodeC which form a triangle
| <<algorithms-triangle-count-clustering-coefficient-syntax, algo.triangleCount>>                          | CALL algo.triangleCount(label, relationship, {concurrency:4, write:true, writeProperty:'triangles', clusteringCoefficientProperty:'coefficient'}) YIELD loadMillis, computeMillis, writeMillis, nodeCount, triangleCount, averageClusteringCoefficient
| <<algorithms-triangle-count-clustering-coefficient-syntax, algo.triangleCount.stream>>                   | CALL algo.triangleCount.stream(label, relationship, {concurrency:8}) YIELD nodeId, triangles - yield nodeId, number of triangles
| <<algorithms-triangle-count-clustering-coefficient-syntax, algo.triangleCount.forkJoin>>                 | CALL algo.triangleCount.forkJoin(label, relationship, {concurrency:4, write:true, writeProperty:'triangles', clusteringCoefficientProperty:'coefficient'}) YIELD loadMillis, computeMillis, writeMillis, nodeCount, triangleCount, averageClusteringCoefficient
| <<algorithms-triangle-count-clustering-coefficient-syntax, algo.triangleCount.forkJoin.stream>>          | CALL algo.triangleCount.forkJoin.stream(label, relationship, {concurrency:8}) YIELD nodeId, triangles - yield nodeId, number of triangles
| <<labs-algorithms-connected-components-imp, algo.unionFind.mscoloring>>                          | CALL algo.unionFind.mscoloring(label:String, relationship:String, {property:'weight', threshold:0.42, defaultValue:1.0, write: true, partitionProperty:'partition', concurrency:4}) YIELD nodes, setCount, loadMillis, computeMillis, writeMillis
| <<labs-algorithms-connected-components-imp, algo.unionFind.mscoloring.stream>>                   | CALL algo.unionFind.mscoloring.stream(label:String, relationship:String, {property:'propertyName', threshold:0.42, defaultValue:1.0, concurrency:4) YIELD nodeId, setId - yields a setId to each node id
| <<labs-algorithms-connected-components-imp, algo.unionFind.forkJoin.stream>>                     | CALL algo.unionFind.stream(label:String, relationship:String, {property:'propertyName', threshold:0.42, defaultValue:1.0,concurrency:4}) YIELD nodeId, setId - yields a setId to each node id
| <<labs-algorithms-connected-components-imp, algo.unionFind.forkJoin>>                            | CALL algo.unionFind(label:String, relationship:String, {property:'weight', threshold:0.42, defaultValue:1.0, write: true, partitionProperty:'partition',concurrency:4}) YIELD nodes, setCount, loadMillis, computeMillis, writeMillis
| <<labs-algorithms-connected-components-imp, algo.unionFind.forkJoinMerge>>                       | CALL algo.unionFind(label:String, relationship:String, {property:'weight', threshold:0.42, defaultValue:1.0, write: true, partitionProperty:'partition', concurrency:4}) YIELD nodes, setCount, loadMillis, computeMillis, writeMillis
| <<labs-algorithms-connected-components-imp, algo.unionFind.forkJoinMerge.stream>>                | CALL algo.unionFind.stream(label:String, relationship:String, {property:'propertyName', threshold:0.42, defaultValue:1.0, concurrency:4}) YIELD nodeId, setId - yields a setId to each node id
| <<labs-algorithms-connected-components-imp, algo.unionFind.queue>>                               | CALL algo.unionFind(label:String, relationship:String, {property:'weight', threshold:0.42, defaultValue:1.0, write: true, partitionProperty:'partition',concurrency:4}) YIELD nodes, setCount, loadMillis, computeMillis, writeMillis
| <<labs-algorithms-connected-components-imp, algo.unionFind.queue.stream>>                        | CALL algo.unionFind.stream(label:String, relationship:String, {property:'propertyName', threshold:0.42, defaultValue:1.0, concurrency:4}) YIELD nodeId, setId - yields a setId to each node id
| algo.version                                                                                             | RETURN algo.version() - return the current graph algorithms installed version
|===

