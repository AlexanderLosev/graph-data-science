// tag::overview[]
[[relationship-deduplication]]
= Relationship Deduplication

ifdef::env-docs[]
[abstract]
--
This chapter explains Relationship deduplication in the Neo4j Graph Algorithms library.
--
endif::env-docs[]

The in-memory graph models available in the Neo4j Graph Algorithms library offer different ways of handling multiple relationships between a given pair of nodes.
By default, the Huge and Heavy graph assume that the relationship projection only contains one relationship between a pair of nodes and will simply ignore all other relationships (see `skip` below).
A Cypher projected graph will, by default, store all projected relationships without any deduplication (see `none` below).

In order to control the deduplication behavior we can pass the `duplicateRelationships` key in the config to decide what should happen with duplicates.

`duplicateRelationships` supports the following options:

* `none` - keeps all relationships between a given pair of nodes / no deduplication.
* `skip` - keeps the first encountered relationship (and associated weight).
* `sum` - sums the associated weights of all encountered relationships.
* `min` - keeps the minimum weight of all encountered relationships.
* `max` - keeps the maximum weight of all encountered relationships.

Note that setting an explict deduplication strategy, other then `none` or `skip` will increase the relationship loading time.

.The following query loads a graph of roads between locations keeping all the `ROAD` relationships between two `LOC` nodes.
[source,cypher]
----
CALL algo.graph.load('allRoads', 'LOC', 'ROAD', {
  graph: 'huge',
  relationshipWeight: 'cost',
  duplicateRelationships: 'none'})
----

.The following query loads a graph of roads between locations keeping only those `ROAD` relationships with the minimal cost.
[source,cypher]
----
CALL algo.graph.load('cheapestRoads', 'LOC', 'ROAD', {
  graph: 'huge',
  relationshipWeight: 'cost',
  duplicateRelationships: 'sum'})
----


.The following runs shortest path over a graph based on Cypher projections, picking the `ROAD` relationship with minimum cost:
[source,cypher]
----
MATCH (start:Loc{name:'A'}), (end:Loc{name:'F'})
CALL algo.shortestPath(start, end, 'cost', {
  nodeQuery:'MATCH(n:Loc) RETURN id(n) as id',
  relationshipQuery:'MATCH(n:Loc)-[r:ROAD]->(m:Loc) RETURN id(n) as source, id(m) as target, r.cost as weight',
  {graph:'cypher', duplicateRelationships: 'min'})
YIELD writeMillis,loadMillis,nodeCount, totalCost
RETURN writeMillis,loadMillis,nodeCount,totalCost
----
