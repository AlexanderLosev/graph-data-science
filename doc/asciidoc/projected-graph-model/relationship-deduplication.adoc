[[relationship-deduplication]]
= Relationship Deduplication

ifdef::env-docs[]
[abstract]
--
This chapter explains Relationship deduplication in the Neo4j Graph Algorithms library.
--
endif::env-docs[]

The in-memory graph models available in the Neo4j Graph Algorithms library offer different ways of handling multiple relationships between a given pair of nodes.
By default, the Huge graph assumes that the relationship projection only contains one relationship between a pair of nodes and will simply ignore all other relationships (see `skip` below).
A Cypher projected graph will, by default, store all projected relationships without any deduplication (see `none` below).

In order to control the deduplication behavior we can pass the `duplicateRelationships` key in the config to decide what should happen with duplicates.

`duplicateRelationships` supports the following options:

* `none` - keeps all relationships between a given pair of nodes / no deduplication.
* `skip` - keeps the first encountered relationship (and associated weight).
* `sum` - sums the associated weights of all encountered relationships.
* `min` - keeps the minimum weight of all encountered relationships.
* `max` - keeps the maximum weight of all encountered relationships.

Note that setting an explict deduplication strategy, other then `none` or `skip` will increase the relationship loading time.

.The following query loads a graph of roads between locations keeping all the `ROAD` relationships between two `LOC` nodes.
[source,cypher]
----
CALL algo.graph.load('allRoads', 'LOC', 'ROAD', {
  graph: 'huge',
  relationshipWeight: 'cost',
  duplicateRelationships: 'none'})
----

.The following query loads a graph of roads between locations keeping only those `ROAD` relationships with the minimal cost.
[source,cypher]
----
CALL algo.graph.load('cheapestRoads', 'LOC', 'ROAD', {
  graph: 'huge',
  relationshipWeight: 'cost',
  duplicateRelationships: 'sum'})
----

// TODO: the upper and lower example are not connected

.The following runs shortest path over a graph based on Cypher projections, picking the `ROAD` relationship with minimum cost:
[source,cypher]
----
MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
CALL algo.shortestPath(start, end, 'cost', {
  nodeQuery:'MATCH (n:Loc) RETURN id(n) as id',
  relationshipQuery:'MATCH (n:Loc)-[r:ROAD]->(m:Loc) RETURN id(n) AS source, id(m) AS target, r.cost AS weight',
  {graph: 'cypher', duplicateRelationships: 'min'})
YIELD writeMillis, loadMillis, nodeCount, totalCost
RETURN writeMillis, loadMillis, nodeCount, totalCost
----

[[multiple-relationship-properties]]
== Multiple relationship properties

In some scenarios, it is useful to load more than one relationship property.
For the `load.graph` procedure, this can be configured via the `relationshipProperties` parameter.

The parameter is configured using a map in which each key refers to a custom property key.
We can refer to that custom property key in all our algorithm procedures that support relationship weights.

The value of that key defines a configuration that is applied during loading.
Within the configuration of each key, we need to specify the Neo4j relationship `property` key we want to load.
Optionally, we can define an `aggregation` function to control the deduplication behavior and a `defaultWeight` (see <<relationship-deduplication>>).

For the following example, let's assume that the `ROAD` relationship stores two properties, the `cost` (distance) and the road `quality` (between 1 and 10).

.The following query loads all roads, deduplicates parallel relationships and aggregates them by their distance and also by their quality.
[source,cypher]
----
CALL algo.graph.load('allRoads', 'LOC', 'ROAD', {
  graph: 'huge',
  relationshipProperties: {
    minDistance: {
        property: 'cost',
        aggregation: 'MIN',
        defaultWeight: 1.0
    },
    maxQuality: {
        property: 'quality',
        aggregation: 'MAX',
        defaultWeight: 5.0
    }
  }})
----

When executed, our `allRoads` graph stores two relationship properties: `minDistance` and `maxQuality`.
We can access the loaded properties by specifying them in an algorithm configuration.
Let's use `algo.shortestPath` again as an example weighted algorithm.

.We first compute the shortest path using the `minDistance` property as weight to compute the path with shortest distance:
[source,cypher]
----
MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
CALL algo.shortestPath(start, end, 'minDistance', {graph: 'allRoads'})
YIELD writeMillis, loadMillis, nodeCount, totalCost
RETURN writeMillis, loadMillis, nodeCount, totalCost
----

.We use the same graph, but the `maxQuality` property if we're interested in the path with the best quality:
[source,cypher]
----
MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
CALL algo.shortestPath(start, end, 'maxQuality', {graph: 'allRoads'})
YIELD writeMillis, loadMillis, nodeCount, totalCost
RETURN writeMillis, loadMillis, nodeCount, totalCost
----

We provide a short-hand syntax for specifying property mappings that allows us to skip the `aggregation` and `defaultWeight`.
If those are omitted, the sytem uses `SKIP` as default aggregation function and `Double.NaN` as default weight.

.The following query loads the graph and allows us to refer to the `cost` property via `distance`:
[source,cypher]
----
CALL algo.graph.load('allRoads', 'LOC', 'ROAD', {
  graph: 'huge',
  relationshipProperties: { distance: 'cost' }
})
----

Note that in this particular shortest path example, using the default weight is not recommended.