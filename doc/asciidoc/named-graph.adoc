[[named-graph]]
= Named graphs

[abstract]
--
This section describes named graphs, which are stored only in memory.
When Neo4j is restarted, named graphs are lost and will need to be reloaded.
--

As it can take some time to load large graphs into the algorithm data structures, you can pre-load graphs and then later refer to them by name when calling graph algorithm procedures.
After usage, they can be removed from memory to free resources used.


== Loading a named graph

We can load named graphs using any of the approaches described in the <<projected-graph-model, projected graph model section>>.

.The following will load a graph with the name `my-graph`, for node label `Label` and relationship type `REL_TYPE`
[source,cypher]
----
CALL algo.graph.load('my-graph','Label','REL_TYPE',{graph:'heavy' /*, ... other config */})
YIELD name, graph, direction, undirected, sorted, nodes, loadMillis, alreadyLoaded,
      nodeWeight, relationshipWeight, nodeProperty, loadNodes, loadRelationships;
----

If we want to load a graph based on a <<cypher-projection, Cypher projection>>, we should specify `graph:'cypher'` in the config.

.The following will load a named graph using Cypher projections for nodes and relationships.
[source,cypher]
----
CALL algo.graph.load('my-graph',
  'MATCH (n) RETURN id(n) AS id',
  'MATCH (a)-->(b) RETURN id(a) AS source, id(b) AS target',
  {graph:'cypher' /*, ... other config */})
YIELD name, graph, direction, undirected, sorted, nodes, loadMillis, alreadyLoaded,
      nodeWeight, relationshipWeight, nodeProperty, loadNodes, loadRelationships;
----

Once we've loaded a named graph we can return details about it.

.The following will return details about a named graph:
[source,cypher]
----
CALL algo.graph.info('my-graph')
YIELD name, type, exists, removed, nodes;
----

Besides node and relationship counts, the procedure can compute information about degree distributions, i.e. the number of relationships per node.
By default, the distribution values are not computed.

.The following will enable computing information about degree distributions:
[source,cypher]
----
CALL algo.graph.info('my-graph', true)
YIELD name, type, exists, removed, nodes, min, max, mean, p50, p75, p90, p95, p99, p999;
----

.In order to set the direction and concurrency for the degree computation, we can provide a parameter map instead:
----
CALL algo.graph.info('my-graph', {direction: 'OUTGOING', concurrency: 8 })
YIELD name, type, exists, removed, nodes, min, max, mean, p50, p75, p90, p95, p99, p999;
----

== Using a named graph

We can use our named graph in queries by specifying its name in the `graph` key of config.

.The following will run the PageRank algorithm on the `my-graph` named graph:
[source,cypher]
----
CALL algo.pageRank(null,null,{graph:'my-graph' /*, ... */})
----

== Loading multiple relationship types

Using the `algo.graph.load` procedure it is possible to load more than one relationship type, as opposed to exactly one type or all types.
In order to specify multiple relationship types, we can provide a relationship type description as known from Cypher `MATCH` pattern declarations.

.The following example will load the graph `my-graph` with relationships that have the type `REL_TYPE1`, `REL_TYPE2` or `REL_TYPE3`:
[source,cypher]
----
CALL algo.graph.load('my-graph', null, 'REL_TYPE1 | REL_TYPE2 | REL_TYPE3', {direction: 'OUTGOING', concurrency: 8 })
----

Having loaded a graph with multiple relationship types gives us several options for how we can use the relationships.

If we call an algorithm with no additional relationship type information, as described in the section above, the algorithm will use all loaded relationships.

However, it is also possible to only use a subset of the loaded relationships by specifying the requested relationship types in the `relationship` parameter for the algorithm.
.The following example will run PageRank only on relationships of type `REL_TYPE1` or `REL_TYPE2`:
[source,cypher]
----
CALL algo.pageRank(null, 'REL_TYPE1 | REL_TYPE2', {graph: 'my-graph'})
----

[NOTE]
====
Specifying a subset of relationship types in an algorithm call only works when the graph was explicitly loaded with multiple relationship types.
If the graph was loaded with `null`, no relationship type information is retained in the graph.
====

[CAUTION]
====
Loading a lot of multiple relationship types can have a negative impact on performace, both during load and execution time.
It is best to only load as few types as needed.
====

== List all named graphs

We can get an overview over all loaded named graphs.

.The following will return information about all currently loaded graphs:
[source,cypher]
----
CALL algo.graph.list()
YIELD name, nodes, relationships, type, direction;
----

== Remove named graph

Once we've finished using the named graph we can remove them to free up memory.

.The following will remove the `my-graph` named graph:
[source,cypher]
----
CALL algo.graph.remove('my-graph')
YIELD name, type, exists, removed, nodes;
----
