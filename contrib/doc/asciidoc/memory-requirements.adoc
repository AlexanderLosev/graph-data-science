[[memory-requirements]]
= Memory Requirements

[abstract]
--
This section describes memory requirements for the projected graph model used by the Neo4j Graph Algorithms Library.
--

The graph algorithms library operates completely on the heap, which means we'll need to configure our Neo4j Server with a much larger heap size than we would for transactional workloads.
The diagram belows shows how memory is used by the projected graph model:

image::graph-model-memory.png[width=500]

The model contains three types of data:

* Node ids - 32 bits per node for "heavy" graph and a maximum of 64 bits per node for "huge"
* Relationships - pairs of node ids
* Weights - stored in a https://github.com/carrotsearch/hppc[HPPC^] map

Memory configuration depends on the graph projection that we're using.

== `algo.memrec` procedure

The `algo.memrec` procedure returns an estimate of the amount of memory required to run graph algorithms.

.Syntax
[source, cypher]
----
CALL algo.memrec(label, relationship, algorithm, config)
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name          | Type    | Default        | Optional | Description
| label         | string  | null           | yes      | The label to load from the graph. If null, load all nodes
| relationship  | string  | null           | yes      | The relationship-type to load from the graph. If null, load all relationships
| algorithm | string  | null     | yes      | The name of a graph algorithm.
h| Config ||||
| direction     | string  | 'OUTGOING'     | yes      | The relationship-direction to use in the algorithm
| graph         | string  | 'heavy'        | yes      | Use 'heavy' when describing the subset of the graph with label and relationship-type parameter. Use 'cypher' for describing the subset with cypher node-statement and relationship-statement
| concurrency   | int     | available CPUs | yes      | The number of concurrent threads
|===

Algorithm specific parameters can also be provided as config.

.Results
[opts="header",cols="1,1,6"]
|===
| Name          | Type    | Description
| requiredMemory         | int     | The required memory in human readable format.
| bytesMin    | int     | The minimum number of bytes required.
| bytesMax | int   | The maximum number of bytes required.
| mapView | Map  | A breakdown of the memory used by different components involved in the execution of a graph algorithm.
|===



== Heavy graph projection

This is the default graph projection, and supports graphs up to 2 billion nodes and 2 billion relationships.
It uses 32 bits (4 bytes) per node, and the amount of memory required can be computed using the following formula:

[source, text]
----
(4 bytes * nodes) + (8 bytes * nodes) + (4 bytes * rels)
----

The amount of memory will be twice this if we use the `direction: "BOTH"` parameter.

We can call the `algo.memrec` procedure
[source,cypher]
----
CALL algo.memrec()
YIELD requiredMemory, bytesMin, bytesMax
RETURN requiredMemory, bytesMin, bytesMax
----

.Results
[opts="header",cols="1,1,1"]
|===
| Required Memory | Bytes Min | Bytes Max
| 10288 Bytes  | 10288    | 10288
|===



== Huge graph projection

This graph projection supports graphs with more than 2 billion nodes or 2 billion relationships.
It stores data in a compressed structure, based on delta encoded sorted id-ranges, which uses a maximum of 64 bits (8 bytes) per node.



.The following will run the algorithm and write back results:
[source, cypher]
----
CALL algo.memrec(null, null, "pageRank")
YIELD mapView
RETURN mapView["memoryUsage"] AS totalMemoryUsage,
       [item in mapView["components"] | {name: item.name, memoryUsage: item.memoryUsage}] AS components
----

