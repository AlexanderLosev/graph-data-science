[[memory-requirements]]
= Memory Requirements

[abstract]
--
This section describes memory requirements for the projected graph model used by the Neo4j Graph Algorithms Library.
--

The graph algorithms library operates completely on the heap, which means we'll need to configure our Neo4j Server with a much larger heap size than we would for transactional workloads.
The diagram belows shows how memory is used by the projected graph model:

image::graph-model-memory.png[width=500]

The model contains three types of data:

* Node ids - 32 bits per node for "heavy" graph and a maximum of 64 bits per node for "huge"
* Relationships - pairs of node ids
* Weights - stored in a https://github.com/carrotsearch/hppc[HPPC^] map

Memory configuration depends on the graph projection that we're using.

== `algo.memrec` procedure

The `algo.memrec` procedure returns an estimate of the amount of memory required to run graph algorithms.

.Syntax
[source, cypher]
----
CALL algo.memrec(label, relationship, algorithm, config)
----

.Parameters
[opts="header",cols="1,1,1,1,4"]
|===
| Name          | Type    | Default        | Optional | Description
| label         | string  | null           | yes      | The label to load from the graph. If null, load all nodes
| relationship  | string  | null           | yes      | The relationship-type to load from the graph. If null, load all relationships
| algorithm | string  | null     | yes      | The name of a graph algorithm or `graph.load` to return the memory requirements for the in memory graph only.
h| Config ||||
| direction     | string  | 'OUTGOING'     | yes      | The relationship-direction to use in the algorithm
| graph         | string  | 'heavy'        | yes      | Use 'heavy' when describing the subset of the graph with label and relationship-type parameter. Use 'cypher' for describing the subset with cypher node-statement and relationship-statement
| concurrency   | int     | available CPUs | yes      | The number of concurrent threads
|===

Algorithm specific parameters can also be provided as config.

.Results
[opts="header",cols="1,1,6"]
|===
| Name          | Type    | Description
| requiredMemory         | int     | The required memory in human readable format.
| bytesMin    | int     | The minimum number of bytes required.
| bytesMax | int   | The maximum number of bytes required.
| mapView | Map  | A breakdown of the memory used by different components involved in the execution of a graph algorithm.
|===

[NOTE]
====
`algo.memrec(label, relationship, algorithm, config)` maps to `algo.<algorithm>.memrec(label, relationship, config)`, which means that `CALL algo.memrec(null, null, "pageRank")` is equivalent to `CALL algo.pageRank.memrec(null, null)`
====

== `algo.memrec` sample

This sample will explain the `algo.memrec` procedure, using a Game of Thrones graphs.

.The following creates a graph containing Game of Thrones characters and the interactions between them.
[source, cypher]
----
CREATE CONSTRAINT ON (c:Character) ASSERT c.id IS UNIQUE;

UNWIND range(1,7) AS season
LOAD CSV WITH HEADERS FROM "https://github.com/neo4j-apps/neuler/raw/master/sample-data/got/got-s" + season + "-nodes.csv" AS row
MERGE (c:Character {id: row.Id})
ON CREATE SET c.name = row.Label;

UNWIND range(1,7) AS season
LOAD CSV WITH HEADERS FROM "https://github.com/neo4j-apps/neuler/raw/master/sample-data/got/got-s" + season + "-edges.csv" AS row
MATCH (source:Character {id: row.Source})
MATCH (target:Character {id: row.Target})
CALL apoc.merge.relationship(source, "INTERACTS_SEASON" + season, {}, {}, target) YIELD rel
SET rel.weight = toInteger(row.Weight);
----

=== Heavy graph projection

This is the default graph projection, and supports graphs up to 2 billion nodes and 2 billion relationships.
It uses 32 bits (4 bytes) per node, and the amount of memory required can be computed using the following formula:

[source, text]
----
(4 bytes * nodes) + (8 bytes * nodes) + (4 bytes * rels)
----


The amount of memory used for relationships will be twice this if we use the `direction: "BOTH"` parameter.

.The following computes the amount of memory required by the heavy in memory graph for any node label and any relationship type:
[source,cypher]
----
CALL algo.memrec(null, null, "graph.load")
YIELD nodes, relationships, requiredMemory, bytesMin, bytesMax
RETURN nodes, relationships, requiredMemory, bytesMin, bytesMax
----

.Results
[opts="header",cols="1,1,1,1,1"]
|===
| Nodes | Relationships | Required Memory | Bytes Min | Bytes Max
| 400 | 3551 | 40 KiB  | 41456    | 41456
|===

.The following computes the amount of memory required by the heavy in memory graph for node label `Character` and relationship type `INTERACTS_SEASON1`:
[source,cypher]
----
CALL algo.memrec("Character", "INTERACTS_SEASON1", "graph.load")
YIELD nodes, relationships, requiredMemory, bytesMin, bytesMax
RETURN nodes, relationships, requiredMemory, bytesMin, bytesMax
----

.Results
[opts="header",cols="1,1,1,1,1"]
|===
| Nodes | Relationships | Required Memory | Bytes Min | Bytes Max
| 400 | 550 | 27 KiB  | 28656    | 28656
|===

.The following computes the amount of memory required by the heavy in memory graph for node label `Character`, relationship type `INTERACTS_SEASON1`, and direction `BOTH`:
[source,cypher]
----
CALL algo.memrec("Character", "INTERACTS_SEASON1", "graph.load", {direction: "BOTH"})
YIELD nodes, relationships, requiredMemory, bytesMin, bytesMax
RETURN nodes, relationships, requiredMemory, bytesMin, bytesMax
----

.Results
[opts="header",cols="1,1,1,1,1"]
|===
| Nodes | Relationships | Required Memory | Bytes Min | Bytes Max
| 400 | 550 | 40 KiB  | 41488    | 41488
|===


=== Huge graph projection

This graph projection supports graphs with more than 2 billion nodes or 2 billion relationships.
It stores data in a compressed structure, based on delta encoded sorted id-ranges, which uses a maximum of 64 bits (8 bytes) per node.

.The following computes the amount of memory required by the huge in memory graph for any node label and any relationship type:
[source,cypher]
----
CALL algo.memrec(null, null, "graph.load", {graph: "huge"})
YIELD nodes, relationships, requiredMemory, bytesMin, bytesMax
RETURN nodes, relationships, requiredMemory, bytesMin, bytesMax
----

.Results
[opts="header",cols="1,1,1,1,1"]
|===
| Nodes | Relationships | Required Memory | Bytes Min | Bytes Max
| 400 | 3551 | 299 KiB  | 306688    | 306688
|===

.The following computes the amount of memory required by the huge in memory graph for node label `Character` and relationship type `INTERACTS_SEASON1`:
[source,cypher]
----
CALL algo.memrec("Character", "INTERACTS_SEASON1", "graph.load", {graph: "huge"})
YIELD nodes, relationships, requiredMemory, bytesMin, bytesMax
RETURN nodes, relationships, requiredMemory, bytesMin, bytesMax
----

.Results
[opts="header",cols="1,1,1,1,1"]
|===
| Nodes | Relationships | Required Memory | Bytes Min | Bytes Max
| 400 | 550 | 299 KiB  | 306680    | 306680
|===

.The following computes the amount of memory required by the huge in memory graph for node label `Character`, relationship type `INTERACTS_SEASON1`, and direction `BOTH`:
[source,cypher]
----
CALL algo.memrec("Character", "INTERACTS_SEASON1", "graph.load", {direction: "BOTH", graph: "huge"})
YIELD nodes, relationships, requiredMemory, bytesMin, bytesMax
RETURN nodes, relationships, requiredMemory, bytesMin, bytesMax
----

.Results
[opts="header",cols="1,1,1,1,1"]
|===
| Nodes | Relationships | Required Memory | Bytes Min | Bytes Max
| 400 | 550 | 563 KiB  | 577112    | 577112
|===
